# 插件导入方式文档

## 1. 插件系统概述

TSAuto项目的插件系统支持多种加载方式，适应不同的开发和生产环境需求。插件系统的核心组件包括：

- **PluginLoader**：负责动态加载各类插件模块
- **PluginManager**：负责插件系统的整体管理和协调
- **PluginValidator**：验证插件是否符合接口规范
- **静态插件映射**：用于生产环境下的插件加载

## 2. 插件加载模式

插件系统支持三种加载模式，可根据不同环境和需求选择：

### 2.1 动态加载模式 (Dynamic)

**适用场景**：开发环境，便于开发和调试

**工作原理**：
- 使用Vite的`import.meta.glob`功能动态扫描和加载插件
- 支持热更新，修改插件后无需重启应用
- 插件内容在运行时动态加载

**优点**：
- 开发效率高，便于调试
- 支持热更新
- 无需重新构建

**缺点**：
- 生产环境性能较低
- 依赖Vite环境

### 2.2 静态加载模式 (Static)

**适用场景**：生产环境，提高性能

**工作原理**：
- 构建时生成静态插件导入映射
- 所有插件在构建时打包到主程序中
- 运行时直接从内存加载，无需动态导入

**优点**：
- 生产环境性能高
- 支持离线使用
- 构建时类型检查

**缺点**：
- 修改插件需要重新构建
- 灵活性较低

### 2.3 资源目录加载模式 (Resource)

**适用场景**：需要动态添加插件的场景

**工作原理**：
- 从应用的资源目录读取插件文件
- 支持从网络或本地文件系统加载
- 插件内容在运行时动态解析

**优点**：
- 支持动态添加插件
- 无需重新构建应用
- 灵活度高

**缺点**：
- 性能较低
- 安全性需要额外考虑

## 3. 静态插件生成流程

### 3.1 生成脚本

静态插件映射通过`scripts/generate-static-plugins.js`脚本自动生成：

```bash
# 单独生成
npm run generate-plugins

# 构建时自动生成
npm run build
```

### 3.2 生成过程

1. 扫描`plugins`目录下的所有插件文件
2. 为每个插件生成导入语句
3. 创建静态插件映射对象
4. 输出到`src/core/plugin/static-plugins.generated.ts`

### 3.3 生成文件结构

```typescript
/**
 * 静态插件导入映射
 * 自动生成，请勿手动修改
 * 生成时间: 2025-12-02T03:35:00.459Z
 */

import plugin_0 from '../../../../plugins/characters/character_1001.ts';
import plugin_1 from '../../../../plugins/equipment/equip_2001.ts';
// 更多导入语句...

/**
 * 静态插件导入映射
 */
export const staticPluginImports = {
  '/plugins/characters/character_1001.ts': plugin_0,
  '/plugins/equipment/equip_2001.ts': plugin_1,
  // 更多映射...
};
```

## 4. 插件导入API

### 4.1 PluginManager构造函数

```typescript
interface PluginManagerOptions {
  mode?: 'dynamic' | 'static' | 'resource';
  staticPlugins?: Record<string, any>;
  resourceBasePath?: string;
}

const pluginManager = new PluginManager(options);
```

### 4.2 插件导入方法

#### 4.2.1 加载单个插件

```typescript
/**
 * 动态加载单个插件
 * @param path 插件路径
 * @param pluginData 可选的插件数据，用于直接提供插件内容
 * @returns 加载结果
 */
async loadPlugin(path: string, pluginData?: any): Promise<{
  success: boolean;
  id?: string;
  error?: string;
}>;
```

#### 4.2.2 批量导入插件

```typescript
/**
 * 批量导入插件
 * @param pluginPaths 插件路径列表
 * @returns 导入结果，包含成功和失败的插件信息
 */
async importPlugins(pluginPaths: string[]): Promise<{
  success: boolean;
  imported: string[];
  failed: { path: string; error: string }[];
  total: number;
}>;
```

#### 4.2.3 从数据导入单个插件

```typescript
/**
 * 从数据导入单个插件
 * @param pluginData 插件数据对象
 * @param type 插件类型
 * @param customId 可选的自定义插件ID
 * @returns 导入结果
 */
async importPluginFromData(
  pluginData: any,
  type: PluginType,
  customId?: string
): Promise<{
  success: boolean;
  id?: string;
  error?: string;
}>;
```

#### 4.2.4 批量从数据导入插件

```typescript
/**
 * 批量从数据导入插件
 * @param pluginsData 插件数据数组
 * @returns 导入结果
 */
async importPluginsFromData(
  pluginsData: { data: any; type: PluginType; id?: string }[]
): Promise<{
  success: boolean;
  imported: string[];
  failed: { index: number; error: string }[];
  total: number;
}>;
```

#### 4.2.5 获取插件统计信息

```typescript
/**
 * 获取已加载的插件统计信息
 * @returns 插件统计数据
 */
getPluginStats(): {
  total: number;
  byType: Record<PluginType, number>;
  enabled: number;
};
```

## 5. 使用示例

### 5.1 开发环境使用（动态加载）

```typescript
import { PluginManager } from './core/plugin/PluginManager';

// 初始化插件管理器，默认使用动态加载模式
const pluginManager = new PluginManager({
  mode: 'dynamic'
});

// 加载所有插件
await pluginManager.initialize();

// 使用插件数据
const characters = pluginManager.getAllCharacters();
const skills = pluginManager.getAllSkills();
```

### 5.2 生产环境使用（静态加载）

```typescript
import { PluginManager } from './core/plugin/PluginManager';
import { staticPluginImports } from './core/plugin/static-plugins.generated';

// 初始化插件管理器，使用静态加载模式
const pluginManager = new PluginManager({
  mode: 'static',
  staticPlugins: staticPluginImports
});

// 加载所有插件
await pluginManager.initialize();

// 使用插件数据
const characters = pluginManager.getAllCharacters();
```

### 5.3 动态导入插件

```typescript
// 导入单个插件
const result = await pluginManager.loadPlugin('skills/new-skill.ts');
if (result.success) {
  console.log(`成功导入插件: ${result.id}`);
}

// 批量导入插件
const importResult = await pluginManager.importPlugins([
  'skills/skill_1004.ts',
  'characters/character_1002.ts',
  'equipment/equip_2002.ts'
]);

console.log(`成功导入: ${importResult.imported.length} 个插件`);
console.log(`导入失败: ${importResult.failed.length} 个插件`);
```

### 5.4 从数据导入插件

```typescript
// 定义插件数据
const newSkill = {
  id: 'SKILL_9999',
  name: '测试技能',
  cost: {
    type: ResourceType.BATTLE_RESOURCE,
    amount: 10
  },
  activeEffects: [
    {
      type: EffectType.DAMAGE,
      target: TargetType.TARGET,
      damageMultiplier: 2.0,
      baseDamageStat: StatType.ATK
    }
  ],
  metadata: {
    version: '1.0.0',
    author: 'Test Author'
  }
};

// 导入插件
const result = await pluginManager.importPluginFromData(
  newSkill,
  PluginType.SKILL
);

if (result.success) {
  console.log(`成功导入技能插件: ${result.id}`);
}
```

## 6. 插件结构

### 6.1 插件文件格式

每个插件文件应该导出一个默认对象，包含插件的主要内容，可选导出metadata对象：

```typescript
// 技能插件示例
export default {
  id: "SKILL_1001",
  name: "风切",
  cost: {
    type: ResourceType.BATTLE_RESOURCE,
    amount: 0
  },
  activeEffects: [
    {
      type: EffectType.DAMAGE,
      target: TargetType.TARGET,
      damageMultiplier: 1.0,
      baseDamageStat: StatType.ATK  
    }
  ],
  // ... 更多效果定义
};

// 插件元数据
export const metadata = {
  version: "1.0.0",
  author: "TSAuto Team",
  description: "基础攻击技能插件"
};
```

### 6.2 插件类型

插件系统支持以下类型：

- **CHARACTER**：角色插件
- **SKILL**：技能插件
- **EQUIPMENT**：装备插件
- **STATUS**：状态插件
- **EQUIPMENT_SET**：装备套装插件
- **UNKNOWN**：未知类型插件

## 7. 开发流程

### 7.1 开发新插件

1. 在`plugins`目录下创建对应类型的子目录（如`skills`、`characters`）
2. 创建插件文件，按照插件结构编写内容
3. 运行开发服务器，插件会自动加载
4. 测试插件功能

### 7.2 构建生产版本

1. 运行构建命令：`npm run build`
2. 构建脚本会自动生成静态插件映射
3. 构建产物位于`dist`目录

### 7.3 测试插件

测试插件加载功能的测试文件位于`tests/unit/plugins/`目录：

- **PluginLoading.test.ts**：测试插件加载功能
- **PluginManager.test.ts**：测试插件管理器功能
- **PluginValidator.test.ts**：测试插件验证功能

运行测试：

```bash
npm run test
```

## 8. 最佳实践

### 8.1 插件开发

- 为每个插件提供唯一的ID
- 为插件添加详细的元数据
- 遵循插件接口定义，确保类型安全
- 测试插件在不同加载模式下的表现

### 8.2 性能优化

- 生产环境使用静态加载模式
- 按需加载插件，避免一次性加载所有插件
- 优化插件内容，减少不必要的依赖

### 8.3 安全性

- 验证插件内容，防止恶意代码
- 限制插件的访问权限
- 生产环境考虑使用代码签名

## 9. 常见问题

### 9.1 插件加载失败

**可能原因**：
- 插件路径错误
- 插件格式不符合要求
- 插件依赖缺失
- 加载模式配置错误

**解决方法**：
- 检查插件路径是否正确
- 验证插件格式是否符合接口定义
- 检查控制台错误信息
- 确认加载模式配置正确

### 9.2 静态插件映射生成失败

**可能原因**：
- 插件文件格式错误
- 插件目录结构不符合要求
- 生成脚本路径错误

**解决方法**：
- 检查插件文件格式
- 确保插件目录结构正确
- 检查生成脚本配置

### 9.3 插件热更新不生效

**可能原因**：
- 插件文件路径不在扫描范围内
- 开发服务器配置错误
- 浏览器缓存问题

**解决方法**：
- 确认插件文件在正确的目录下
- 检查Vite配置
- 清除浏览器缓存

## 10. 未来扩展

- 支持插件版本管理
- 实现插件依赖管理
- 添加插件商店功能
- 支持插件动态更新
- 实现插件禁用/启用功能

## 11. 总结

TSAuto项目的插件系统设计灵活，支持多种加载方式，能够适应不同的开发和生产环境需求。通过合理选择加载模式，可以在开发效率和运行性能之间取得平衡。

插件系统的API设计简洁易用，支持多种导入方式，便于开发者扩展游戏内容。静态插件映射生成机制确保了生产环境的高性能，同时保持了开发环境的灵活性。

通过遵循本文档的最佳实践和开发流程，可以高效地开发和管理插件，为游戏添加丰富的内容。
