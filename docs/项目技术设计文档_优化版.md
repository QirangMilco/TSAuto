# TSAuto é¡¹ç›®æŠ€æœ¯è®¾è®¡æ–‡æ¡£ (AIåä½œä¼˜åŒ–ç‰ˆ)

**é¡¹ç›®ä»£å·ï¼š** TSAuto  
**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v2.0 (AIåä½œä¼˜åŒ–ç‰ˆ)  
**æœ€åæ›´æ–°ï¼š** 2025-01-07  
**æ ¸å¿ƒè®¾è®¡åŸåˆ™ï¼š** ç•Œé¢ä¸é€»è¾‘åˆ†ç¦»ï¼Œæ”¯æŒå¤šUIæ¡†æ¶æ¥å…¥

---

## ğŸ“‹ ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°ä¸æ ¸å¿ƒç›®æ ‡](#1-é¡¹ç›®æ¦‚è¿°ä¸æ ¸å¿ƒç›®æ ‡)
2. [æ¶æ„è®¾è®¡ç†å¿µ](#2-æ¶æ„è®¾è®¡ç†å¿µ)
3. [ç›®å½•ç»“æ„æ ‘](#3-ç›®å½•ç»“æ„æ ‘)
4. [æŠ€æœ¯æ ˆè¯¦è§£](#4-æŠ€æœ¯æ ˆè¯¦è§£)
5. [ç±»å‹å®šä¹‰ç³»ç»Ÿ (SSOT)](#5-ç±»å‹å®šä¹‰ç³»ç»Ÿ-ssot)
6. [æ ¸å¿ƒæˆ˜æ–—ç³»ç»Ÿ](#6-æ ¸å¿ƒæˆ˜æ–—ç³»ç»Ÿ)
7. [çŠ¶æ€åŒæ­¥ä¸UIæ¡¥æ¥å±‚](#7-çŠ¶æ€åŒæ­¥ä¸uiæ¡¥æ¥å±‚)
8. [å•å…ƒæµ‹è¯•é©±åŠ¨å¼€å‘](#8-å•å…ƒæµ‹è¯•é©±åŠ¨å¼€å‘)
9. [æ’ä»¶ç³»ç»Ÿæ¶æ„](#9-æ’ä»¶ç³»ç»Ÿæ¶æ„)
10. [ä¼¤å®³å…¬å¼ä¸è¾¹ç•Œå¤„ç†](#10-ä¼¤å®³å…¬å¼ä¸è¾¹ç•Œå¤„ç†)
11. [AIåŠ©æ‰‹åä½œæŒ‡å—](#11-aiåŠ©æ‰‹åä½œæŒ‡å—)
12. [éƒ¨ç½²ä¸è·¨å¹³å°ç­–ç•¥](#12-éƒ¨ç½²ä¸è·¨å¹³å°ç­–ç•¥)

---

## 1. é¡¹ç›®æ¦‚è¿°ä¸æ ¸å¿ƒç›®æ ‡

### 1.1 é¡¹ç›®å®šä½
å¼€å‘ä¸€ä¸ª**ä»¥å¤æ‚2Då›åˆåˆ¶æˆ˜æ–—ä¸ºæ ¸å¿ƒ**çš„è·¨å¹³å°åˆ·å­æ¸¸æˆï¼ŒæŠ€æœ¯æ¶æ„æ”¯æŒæœªæ¥æ— ç¼æ¥å…¥ä¸åŒçš„UIæ¡†æ¶ã€‚

### 1.2 æ ¸å¿ƒéœ€æ±‚
- **è·¨å¹³å°è¦†ç›–ï¼š** Windows, macOS, Linux, iOS, Android
- **åŒè¿è¡Œæ¨¡å¼ï¼š** æœ¬åœ°æ¨¡å¼ (IndexedDB) + è”ç½‘æ¨¡å¼ (PostgreSQL + WebSocket)
- **ç•Œé¢é€»è¾‘åˆ†ç¦»ï¼š** æ ¸å¿ƒé€»è¾‘å®Œå…¨ç‹¬ç«‹äºUIæ¡†æ¶ï¼Œæ”¯æŒReactã€Vueã€Angularç­‰
- **å¤æ‚æˆ˜æ–—å¼•æ“ï¼š** å¯¹æ ‡ã€Šé˜´é˜³å¸ˆã€‹çš„æ·±åº¦æˆ˜æ–—æœºåˆ¶
- **åŠ¨æ€æ’ä»¶ç³»ç»Ÿï¼š** è§’è‰²ã€æŠ€èƒ½ã€è£…å¤‡ç­‰çƒ­æ’æ‹”
- **æœ¯è¯­å¯é…ç½®ï¼š** å…¨å±€æœ¯è¯­æ›¿æ¢ï¼Œè§„é¿ç‰ˆæƒé£é™©

---

## 2. æ¶æ„è®¾è®¡ç†å¿µ

### 2.1 æ ¸å¿ƒè®¾è®¡åŸåˆ™

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   UI Framework      â”‚    â”‚   UI Framework      â”‚    â”‚   UI Framework      â”‚
â”‚   (React/Vue/etc)   â”‚    â”‚   (React/Vue/etc)   â”‚    â”‚   (React/Vue/etc)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                          â”‚                          â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚                 â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚   UI Bridge   â”‚ â”‚   UI Bridge   â”‚
                  â”‚   Layer       â”‚ â”‚   Layer       â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚                 â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚        Core Logic             â”‚
                  â”‚   (TypeScript Pure)           â”‚
                  â”‚  - BattleEngine               â”‚
                  â”‚  - TurnManager                â”‚
                  â”‚  - DamageCalculator           â”‚
                  â”‚  - PluginSystem               â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 åˆ†ç¦»å…³æ³¨ç‚¹
- **æ ¸å¿ƒé€»è¾‘å±‚ï¼š** çº¯TypeScriptï¼Œæ— UIä¾èµ–
- **UIæ¡¥æ¥å±‚ï¼š** é€‚é…ä¸åŒUIæ¡†æ¶çš„çŠ¶æ€åŒæ­¥
- **è¡¨ç°å±‚ï¼š** çº¯UIç»„ä»¶ï¼Œæ¸²æŸ“å’ŒåŠ¨ç”»

---

## 3. ç›®å½•ç»“æ„æ ‘

```
TSAuto/
â”œâ”€â”€ docs/                          # é¡¹ç›®æ–‡æ¡£
â”‚   â”œâ”€â”€ é¡¹ç›®æŠ€æœ¯è®¾è®¡æ–‡æ¡£_ä¼˜åŒ–ç‰ˆ.md   # æœ¬æ–‡æ¡£
â”‚   â””â”€â”€ é˜´é˜³å¸ˆæœºåˆ¶åŠæ•°æ®_æ€»ç»“.md     # æ¸¸æˆæœºåˆ¶å‚è€ƒ
â”‚
â”œâ”€â”€ src/                           # æºä»£ç æ ¹ç›®å½•
â”‚   â”œâ”€â”€ core/                      # ğŸ”¥ æ ¸å¿ƒé€»è¾‘å±‚ (UIæ— å…³)
â”‚   â”‚   â”œâ”€â”€ battle/                # æˆ˜æ–—ç³»ç»Ÿæ ¸å¿ƒ
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleEngine.ts    # æˆ˜æ–—å¼•æ“
â”‚   â”‚   â”‚   â”œâ”€â”€ TurnManager.ts     # å›åˆç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ DamageCalculator.ts # ä¼¤å®³è®¡ç®—
â”‚   â”‚   â”‚   â””â”€â”€ types/             # æˆ˜æ–—ç›¸å…³ç±»å‹
â”‚   â”‚   â”œâ”€â”€ config/                # é…ç½®ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ terms.ts           # æœ¯è¯­é…ç½® (SSOT)
â”‚   â”‚   â”‚   â””â”€â”€ gameConfig.ts      # æ¸¸æˆé…ç½®
â”‚   â”‚   â”œâ”€â”€ services/              # ä¸šåŠ¡æœåŠ¡
â”‚   â”‚   â”‚   â”œâ”€â”€ CharacterStatsService.ts # è§’è‰²å±æ€§è®¡ç®—
â”‚   â”‚   â”‚   â”œâ”€â”€ EquipmentService.ts      # è£…å¤‡ç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ FormulaService.ts        # å…¬å¼æœåŠ¡
â”‚   â”‚   â”‚   â””â”€â”€ RandomService.ts         # éšæœºæ•°æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ types/                 # ğŸ”¥ ç±»å‹å®šä¹‰ (SSOT)
â”‚   â”‚   â”‚   â”œâ”€â”€ definitions.ts    # æ ¸å¿ƒæ¥å£å®šä¹‰
â”‚   â”‚   â”‚   â”œâ”€â”€ battle.ts         # æˆ˜æ–—çŠ¶æ€ç±»å‹
â”‚   â”‚   â”‚   â””â”€â”€ plugin.ts         # æ’ä»¶ç±»å‹
â”‚   â”‚   â”œâ”€â”€ plugin-system/         # æ’ä»¶ç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ PluginManager.ts  # æ’ä»¶ç®¡ç†å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ Loader.ts         # æ’ä»¶åŠ è½½å™¨
â”‚   â”‚   â”‚   â””â”€â”€ validators/       # æ’ä»¶éªŒè¯å™¨
â”‚   â”‚   â””â”€â”€ utils/                # å·¥å…·å‡½æ•°
â”‚   â”‚
â”‚   â”œâ”€â”€ ui-bridge/                 # ğŸ”¥ UIæ¡¥æ¥å±‚ (å¯é€‚é…å¤šæ¡†æ¶)
â”‚   â”‚   â”œâ”€â”€ react/                # Reacté€‚é…å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ useBattleStore.ts # ZustandçŠ¶æ€æ¡¥æ¥
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleAdapter.ts  # æˆ˜æ–—çŠ¶æ€é€‚é…å™¨
â”‚   â”‚   â”‚   â””â”€â”€ hooks/            # Reactä¸“ç”¨hooks
â”‚   â”‚   â”œâ”€â”€ vue/                  # Vueé€‚é…å™¨ (æœªæ¥æ‰©å±•)
â”‚   â”‚   â”œâ”€â”€ angular/              # Angularé€‚é…å™¨ (æœªæ¥æ‰©å±•)
â”‚   â”‚   â””â”€â”€ common/               # é€šç”¨æ¡¥æ¥æ¥å£
â”‚   â”‚
â”‚   â”œâ”€â”€ ui-react/                  # ğŸ”¥ React UIå±‚ (å¯æ›¿æ¢)
â”‚   â”‚   â”œâ”€â”€ components/           # Reactç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleScene.tsx   # æˆ˜æ–—åœºæ™¯
â”‚   â”‚   â”‚   â”œâ”€â”€ CharacterAvatar.tsx # è§’è‰²å¤´åƒ
â”‚   â”‚   â”‚   â”œâ”€â”€ SkillBar.tsx      # æŠ€èƒ½æ 
â”‚   â”‚   â”‚   â””â”€â”€ common/           # é€šç”¨UIç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ pages/                # é¡µé¢ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ stores/               # ReactçŠ¶æ€ç®¡ç†
â”‚   â”‚   â””â”€â”€ styles/               # æ ·å¼æ–‡ä»¶
â”‚   â”‚
â”‚   â”œâ”€â”€ plugins/                   # ğŸ”¥ æ’ä»¶ç›®å½• (åŠ¨æ€åŠ è½½)
â”‚   â”‚   â”œâ”€â”€ characters/           # è§’è‰²æ’ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ character_1001.ts # è§’è‰²å®šä¹‰
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”œâ”€â”€ skills/               # æŠ€èƒ½æ’ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ skill_1001.ts     # æŠ€èƒ½å®šä¹‰
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”œâ”€â”€ equipment/            # è£…å¤‡æ’ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ equip_2001.ts     # è£…å¤‡å®šä¹‰
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â””â”€â”€ statuses/             # çŠ¶æ€æ’ä»¶
â”‚   â”‚       â”œâ”€â”€ status_3001.ts    # çŠ¶æ€å®šä¹‰
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”‚
â”‚   â”œâ”€â”€ assets/                    # é™æ€èµ„æº
â”‚   â”‚   â”œâ”€â”€ images/               # å›¾ç‰‡èµ„æº
â”‚   â”‚   â”œâ”€â”€ audio/                # éŸ³é¢‘èµ„æº
â”‚   â”‚   â””â”€â”€ fonts/                # å­—ä½“èµ„æº
â”‚   â”‚
â”‚   â””â”€â”€ utils/                     # é€šç”¨å·¥å…·
â”‚       â”œâ”€â”€ math/                  # æ•°å­¦å·¥å…·
â”‚       â”œâ”€â”€ string/                # å­—ç¬¦ä¸²å·¥å…·
â”‚       â””â”€â”€ validation/            # éªŒè¯å·¥å…·
â”‚
â”œâ”€â”€ tests/                         # ğŸ”¥ æµ‹è¯•ç›®å½• (TDDé©±åŠ¨)
â”‚   â”œâ”€â”€ unit/                     # å•å…ƒæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ core/                 # æ ¸å¿ƒé€»è¾‘æµ‹è¯•
â”‚   â”‚   â”‚   â”œâ”€â”€ battle/           # æˆ˜æ–—ç³»ç»Ÿæµ‹è¯•
â”‚   â”‚   â”‚   â”œâ”€â”€ services/         # æœåŠ¡å±‚æµ‹è¯•
â”‚   â”‚   â”‚   â””â”€â”€ types/            # ç±»å‹æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ plugins/              # æ’ä»¶æµ‹è¯•
â”‚   â”‚   â””â”€â”€ utils/                # å·¥å…·æµ‹è¯•
â”‚   â”œâ”€â”€ integration/              # é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ e2e/                      # ç«¯åˆ°ç«¯æµ‹è¯•
â”‚
â”œâ”€â”€ build/                         # æ„å»ºè¾“å‡º
â”œâ”€â”€ dist/                          # å‘å¸ƒç›®å½•
â””â”€â”€ package.json                   # é¡¹ç›®é…ç½®
```

---

## 4. æŠ€æœ¯æ ˆè¯¦è§£

### 4.1 æ ¸å¿ƒå±‚ (UIæ— å…³)
- **è¯­è¨€ï¼š** TypeScript 5.0+
- **æ„å»ºï¼š** Vite 5.0+
- **æµ‹è¯•ï¼š** Vitest + Testing Library

### 4.2 UIæ¡¥æ¥å±‚
- **Reacté€‚é…ï¼š** Zustand + React 18 + TailwindCSS
- **Vueé€‚é…ï¼š** Pinia + Vue 3 (è§„åˆ’ä¸­)
- **é€šç”¨æ¥å£ï¼š** æ ‡å‡†åŒ–çŠ¶æ€å’Œäº‹ä»¶æ¥å£

### 4.3 è·¨å¹³å°å°è£…
- **æ¡Œé¢ï¼š** Tauri 2.0
- **ç§»åŠ¨ï¼š** Capacitor 6.0

### 4.4 æœåŠ¡ç«¯
- **åç«¯ï¼š** NestJS + TypeScript
- **æ•°æ®åº“ï¼š** PostgreSQL + Redis
- **å®æ—¶é€šä¿¡ï¼š** WebSocket

---

## 5. ç±»å‹å®šä¹‰ç³»ç»Ÿ (SSOT)

### 5.1 å•ä¸€äº‹å®æ¥æºåŸåˆ™

**âš ï¸ å…³é”®çº¦æŸï¼š** æ‰€æœ‰ç±»å‹å®šä¹‰å¿…é¡»é›†ä¸­åœ¨ `src/core/types/` ç›®å½•ï¼Œç¦æ­¢åœ¨å…¶ä»–æ–‡ä»¶ä¸­å®šä¹‰é‡å¤ç±»å‹ã€‚

### 5.2 æ ¸å¿ƒç±»å‹å®šä¹‰

**`src/core/types/definitions.ts`**

```typescript
/**
 * TSAuto æ¸¸æˆæ ¸å¿ƒç±»å‹å®šä¹‰
 * âš ï¸ æ³•å¾‹æ–‡ä»¶ï¼šç¦æ­¢ä¿®æ”¹æ­¤æ–‡ä»¶ä¸­çš„æ¥å£å®šä¹‰
 */

// ==================== åŸºç¡€æšä¸¾ ====================

export enum BattleEventType {
  ON_BATTLE_START = "ON_BATTLE_START",
  ON_TURN_START = "ON_TURN_START", 
  ON_TURN_END = "ON_TURN_END",
  ON_DAMAGE_DEALT = "ON_DAMAGE_DEALT",
  ON_HEAL_RECEIVED = "ON_HEAL_RECEIVED",
  ON_STATUS_APPLIED = "ON_STATUS_APPLIED",
  ON_STATUS_REMOVED = "ON_STATUS_REMOVED",
  ON_CHARACTER_DEATH = "ON_CHARACTER_DEATH",
  ON_PSEUDO_TURN_START = "ON_PSEUDO_TURN_START",
  ON_PSEUDO_TURN_END = "ON_PSEUDO_TURN_END"
}

export enum TurnType {
  NORMAL = "NORMAL",           // çœŸå›åˆ - æ¨è¿›èµ„æºæ¡
  NEW_TURN = "NEW_TURN",       // æ–°å›åˆ - ä¸æ¨è¿›èµ„æºæ¡
  PSEUDO_TURN = "PSEUDO_TURN"  // ä¼ªå›åˆ - ä¸æ¨è¿›èµ„æºæ¡
}

export enum EffectType {
  DAMAGE = "DAMAGE",
  HEAL = "HEAL", 
  APPLY_STATUS = "APPLY_STATUS",
  MODIFY_ACTION_BAR = "MODIFY_ACTION_BAR",
  GAIN_EXTRA_TURN = "GAIN_EXTRA_TURN",
  TRIGGER_PSEUDO_TURN = "TRIGGER_PSEUDO_TURN",
  MODIFY_RESOURCE = "MODIFY_RESOURCE"
}

export enum TargetType {
  SELF = "SELF",
  TARGET = "TARGET", 
  ALL_ALLIES = "ALL_ALLIES",
  ALL_ENEMIES = "ALL_ENEMIES",
  RANDOM_ENEMY = "RANDOM_ENEMY",
  RANDOM_ALLY = "RANDOM_ALLY"
}

export enum StatType {
  // åŸºç¡€å±æ€§
  HP = "HP",           // ç”Ÿå‘½å€¼
  ATK = "ATK",         // æ”»å‡»
  DEF = "DEF",         // é˜²å¾¡  
  SPD = "SPD",         // é€Ÿåº¦
  CRIT = "CRIT",       // æš´å‡»ç‡
  CRIT_DMG = "CRIT_DMG", // æš´å‡»ä¼¤å®³
  
  // ç™¾åˆ†æ¯”å±æ€§
  ATK_P = "ATK_P",     // æ”»å‡»åŠ æˆ(%)
  DEF_P = "DEF_P",     // é˜²å¾¡åŠ æˆ(%)
  HP_P = "HP_P",       // ç”Ÿå‘½åŠ æˆ(%)
  
  // ç‰¹æ®Šå±æ€§
  DMG_BONUS = "DMG_BONUS",         // ä¼¤å®³åŠ æˆ
  DMG_TAKEN_BONUS = "DMG_TAKEN_BONUS", // æ‰¿å—ä¼¤å®³åŠ æˆ
  IGNORE_DEF_P = "IGNORE_DEF_P",   // æ— è§†é˜²å¾¡(%)
  IGNORE_DEF_FLAT = "IGNORE_DEF_FLAT" // å¿½ç•¥é˜²å¾¡(å›ºå®šå€¼)
}

export enum BuffType {
  ATK_UP = "ATK_UP",           // æ”»å‡»æå‡
  DEF_UP = "DEF_UP",           // é˜²å¾¡æå‡
  SPD_UP = "SPD_UP",           // é€Ÿåº¦æå‡
  INVINCIBLE = "INVINCIBLE",   // æ— æ•Œ
  FROZEN = "FROZEN",           // å†°å†»
  BURNING = "BURNING",         // ç¼çƒ§
  POISONED = "POISONED"        // ä¸­æ¯’
}

// ==================== æ ¸å¿ƒæ¥å£ ====================

/**
 * å¯æ‰§è¡Œæ•ˆæœ
 * âš ï¸ è¿™ä¸ªæ¥å£å®šä¹‰äº†æ‰€æœ‰å¯èƒ½çš„æŠ€èƒ½æ•ˆæœ
 */
export interface Effect {
  type: EffectType;
  target: TargetType;
  
  // MODIFY_ACTION_BAR ä¸“ç”¨
  amount?: number; // æ¨æ‹‰æ¡æ¯”ä¾‹ï¼Œå¦‚ 0.3 = æ‹‰æ¡30%
  
  // GAIN_EXTRA_TURN & TRIGGER_PSEUDO_TURN ä¸“ç”¨  
  pseudoTurnSkillId?: string;
  
  // DAMAGE ä¸“ç”¨
  damageMultiplier?: number; // ä¼¤å®³ç³»æ•°ï¼Œå¦‚ 1.2 = 120%æ”»å‡»
  baseDamageStat?: StatType; // åŸºç¡€ä¼¤å®³å±æ€§ç±»å‹ï¼ˆç”¨äºä¼¤å®³è®¡ç®—ï¼‰
  
  // HEAL ä¸“ç”¨
  healMultiplier?: number; // æ²»ç–—ç³»æ•°
  baseHealStat?: StatType; // åŸºç¡€æ²»ç–—å±æ€§ç±»å‹ï¼ˆç”¨äºæ²»ç–—è®¡ç®—ï¼‰
  
  // APPLY_STATUS ä¸“ç”¨
  statusId?: string; // è¦æ–½åŠ çš„çŠ¶æ€ID
  duration?: number; // çŠ¶æ€æŒç»­å›åˆæ•°
}

/**
 * è§’è‰²å®šä¹‰ (æ’ä»¶æ¥å£)
 */
export interface CharacterDefinition {
  id: string; // å”¯ä¸€æ ‡è¯†ï¼Œå¦‚ "CHAR_1001"
  name: string; // æ˜¾ç¤ºåç§°
  
  assets: {
    avatar: string; // å¤´åƒå›¾ç‰‡è·¯å¾„
    portrait: string; // ç«‹ç»˜å›¾ç‰‡è·¯å¾„
  };
  
  // æˆé•¿å€¼ç³»ç»Ÿ (åŸºç¡€æ•°æ®)
  growthValues: {
    hp: number;     // ç”Ÿå‘½æˆé•¿å€¼
    atk: number;    // æ”»å‡»æˆé•¿å€¼  
    def: number;    // é˜²å¾¡æˆé•¿å€¼
    spd: number;    // é€Ÿåº¦ (é€šå¸¸å›ºå®š)
    crit: number;   // æš´å‡»ç‡æˆé•¿
    critDmg: number; // æš´å‡»ä¼¤å®³æˆé•¿
  };
  
  skills: [string, string, string]; // æŠ€èƒ½IDæ•°ç»„
}

/**
 * æŠ€èƒ½å®šä¹‰ (æ’ä»¶æ¥å£)
 */
export interface SkillDefinition {
  id: string; // å”¯ä¸€æ ‡è¯†ï¼Œå¦‚ "SKILL_1001"
  name: string; // æŠ€èƒ½åç§°
  
  // æŠ€èƒ½æ¶ˆè€—
  cost: {
    type: "BATTLE_RESOURCE"; 
    amount: number;
  };
  
  activeEffects?: Effect[]; // ä¸»åŠ¨æ•ˆæœ
  passiveListeners?: {     // è¢«åŠ¨ç›‘å¬
    event: BattleEventType;
    effects: Effect[];
  }[];
  
  // æŠ€èƒ½æè¿° (å¯é€‰ï¼Œç”¨äºUIæ˜¾ç¤º)
  description?: string;
}

/**
 * è£…å¤‡å®šä¹‰ (æ’ä»¶æ¥å£)
 */
export interface EquipmentDefinition {
  id: string; // å”¯ä¸€æ ‡è¯†ï¼Œå¦‚ "EQUIP_2001"
  name: string; // è£…å¤‡åç§°
  setId: string; // å¥—è£…ID
  slot: 1 | 2 | 3 | 4 | 5 | 6; // è£…å¤‡ä½
  
  // åŸºç¡€å±æ€§
  baseStats?: Partial<Record<StatType, number>>;
  
  // å‰¯å±æ€§é€‰é¡¹ (ç”¨äºéšæœºç”Ÿæˆ)
  possibleSecondaryStats?: StatType[];
}

/**
 * çŠ¶æ€å®šä¹‰ (æ’ä»¶æ¥å£)
 */
export interface StatusDefinition {
  id: string; // å”¯ä¸€æ ‡è¯†
  name: string; // çŠ¶æ€åç§°
  type: BuffType; // çŠ¶æ€ç±»å‹
  
  duration?: number; // æŒç»­å›åˆæ•°ï¼Œundefined = æ°¸ä¹…
  
  // çŠ¶æ€æ•ˆæœ
  statModifiers?: Partial<Record<StatType, number>>;
  
  // ç‰¹æ®Šè¡Œä¸º
  onTurnStart?: Effect[]; // å›åˆå¼€å§‹æ—¶è§¦å‘
  onTurnEnd?: Effect[];   // å›åˆç»“æŸæ—¶è§¦å‘
  onReceiveDamage?: Effect[]; // å—åˆ°ä¼¤å®³æ—¶è§¦å‘
}
```

**`src/core/types/battle.ts`**

```typescript
import type { StatType, BuffType } from './definitions';

/**
 * æˆ˜æ–—çŠ¶æ€ç›¸å…³ç±»å‹
 */

/**
 * è§’è‰²å®ä¾‹ (è¿è¡Œæ—¶çŠ¶æ€)
 */
export interface CharacterInstance {
  instanceId: string; // å®ä¾‹ID (å”¯ä¸€)
  characterId: string; // è§’è‰²å®šä¹‰ID
  
  // å½“å‰é¢æ¿å±æ€§ (è®¡ç®—å)
  currentStats: Record<StatType, number>;
  
  // è¡ŒåŠ¨æ¡çŠ¶æ€
  actionBarPosition: number; // å½“å‰ä½ç½® (0-å…¨åœºä¸€é€Ÿ)
  
  // çŠ¶æ€ç®¡ç†
  statuses: CharacterStatus[];
  
  // ç”Ÿå‘½çŠ¶æ€
  isDead: boolean;
  
  // è£…å¤‡
  equipment: string[]; // è£…å¤‡å®ä¾‹IDæ•°ç»„
}

/**
 * è§’è‰²çŠ¶æ€å®ä¾‹
 */
export interface CharacterStatus {
  statusId: string; // çŠ¶æ€å®šä¹‰ID
  remainingTurns: number; // å‰©ä½™å›åˆæ•°
  stackCount: number; // å åŠ å±‚æ•°
}

/**
 * æˆ˜æ–—çŠ¶æ€ (å…¨å±€)
 */
export interface BattleState {
  battleId: string;
  round: number; // å½“å‰å›åˆæ•°
  
  // å‚æˆ˜è§’è‰²
  players: CharacterInstance[];
  enemies: CharacterInstance[];
  
  // å½“å‰è¡ŒåŠ¨è€…
  activeCharacterId: string | null;
  
  // æˆ˜æ–—èµ„æº
  resourceManager: ResourceManager;
  
  // æˆ˜æ–—ç»“æœ
  result: "IN_PROGRESS" | "VICTORY" | "DEFEAT";
}

/**
 * èµ„æºç®¡ç†å™¨
 */
export interface ResourceManager {
  currentResource: number; // å½“å‰èµ„æºé‡
  maxResource: number;     // æœ€å¤§èµ„æºé‡
  
  advance(turns?: number): void; // æ¨è¿›èµ„æºæ¡
  consume(amount: number): boolean; // æ¶ˆè€—èµ„æº
}

/**
 * æˆ˜æ–—äº‹ä»¶
 */
export interface BattleEvent {
  type: string;
  timestamp: number;
  data: any;
}
```

### 5.3 ç±»å‹éªŒè¯è§„åˆ™

**å¼€å‘çº¦æŸï¼š**
1. **ç¦æ­¢é‡å¤å®šä¹‰ï¼š** ç›¸åŒæ¦‚å¿µçš„æ¥å£ä¸å¾—åœ¨ä¸åŒæ–‡ä»¶ä¸­é‡å¤å®šä¹‰
2. **ç¦æ­¢æ‰©å±•æœªå®šä¹‰å±æ€§ï¼š** ä¸å¾—ä¸ºæ¥å£æ·»åŠ æ–‡æ¡£ä¸­æœªåˆ—å‡ºçš„å±æ€§
3. **ä¸¥æ ¼ç±»å‹æ£€æŸ¥ï¼š** æ‰€æœ‰ä»£ç å¿…é¡»é€šè¿‡TypeScriptä¸¥æ ¼æ¨¡å¼æ£€æŸ¥

---

## 6. æ ¸å¿ƒæˆ˜æ–—ç³»ç»Ÿ

### 6.1 æˆ˜æ–—å¼•æ“æ¶æ„

**`src/core/battle/BattleEngine.ts`**

```typescript
import type { 
  CharacterDefinition, 
  SkillDefinition, 
  Effect,
  TurnType 
} from '../types/definitions';
import type { 
  BattleState, 
  CharacterInstance, 
  ResourceManager 
} from '../types/battle';
import { TurnManager } from './TurnManager';
import { DamageCalculator } from './DamageCalculator';
import { EventEmitter } from '../utils/EventEmitter';
import { GameData } from '../plugin-system/GameData';

/**
 * æˆ˜æ–—å¼•æ“æ ¸å¿ƒç±»
 * âš ï¸ çº¯é€»è¾‘å±‚ï¼Œæ— UIä¾èµ–
 * 
 * æ ¸å¿ƒèŒè´£ï¼š
 * 1. ç®¡ç†æˆ˜æ–—çŠ¶æ€
 * 2. å¤„ç†å›åˆæµç¨‹
 * 3. æ‰§è¡ŒæŠ€èƒ½æ•ˆæœ
 * 4. è§¦å‘æˆ˜æ–—äº‹ä»¶
 */
export class BattleEngine {
  private state: BattleState;
  private eventBus: EventEmitter;
  private turnManager: TurnManager;
  private onStateChange?: (state: BattleState) => void;

  constructor(
    playerTeam: CharacterDefinition[],
    enemyTeam: CharacterDefinition[],
    onStateChangeCallback?: (state: BattleState) => void
  ) {
    this.onStateChange = onStateChangeCallback;
    this.eventBus = new EventEmitter();
    
    // åˆå§‹åŒ–æˆ˜æ–—çŠ¶æ€
    this.state = this.createInitialBattleState(playerTeam, enemyTeam);
    this.turnManager = new TurnManager([...this.state.players, ...this.state.enemies]);
    
    // æ¨é€åˆå§‹çŠ¶æ€
    this.notifyStateChange();
  }

  /**
   * å¼€å§‹æˆ˜æ–—
   */
  public async startBattle(): Promise<void> {
    this.eventBus.emit('BATTLE_START', { battleId: this.state.battleId });
    
    // æˆ˜æ–—ä¸»å¾ªç¯
    while (this.state.result === 'IN_PROGRESS') {
      const activeChar = this.turnManager.getNextTurn();
      if (!activeChar) break;
      
      await this.processTurn(activeChar);
    }
  }

  /**
   * å¤„ç†å•ä¸ªå›åˆ
   */
  private async processTurn(character: CharacterInstance): Promise<void> {
    const isPlayer = this.state.players.includes(character);
    const turnType = this.determineTurnType(character);
    
    // æ¨è¿›èµ„æºæ¡ (ä»…çœŸå›åˆ)
    if (turnType === TurnType.NORMAL) {
      this.state.resourceManager.advance();
    }
    
    this.state.activeCharacterId = character.instanceId;
    this.eventBus.emit('TURN_START', { 
      character, 
      turnType,
      round: this.state.round 
    });
    
    if (isPlayer) {
      // ç­‰å¾…ç©å®¶è¾“å…¥
      const action = await this.waitForPlayerAction(character);
      await this.executeAction(character, action.skillId, action.targetId, turnType);
    } else {
      // AIè‡ªåŠ¨å†³ç­–
      const action = this.aiDecideAction(character);
      await this.executeAction(character, action.skillId, action.targetId, turnType);
    }
    
    this.eventBus.emit('TURN_END', { character, turnType });
    
    // æ£€æŸ¥æˆ˜æ–—ç»“æŸæ¡ä»¶
    this.checkBattleEnd();
  }

  /**
   * æ‰§è¡ŒæŠ€èƒ½åŠ¨ä½œ
   */
  public async executeAction(
    caster: CharacterInstance, 
    skillId: string, 
    targetId: string, 
    turnType: TurnType
  ): Promise<void> {
    const skill = GameData.getSkill(skillId);
    if (!skill) {
      throw new Error(`Skill not found: ${skillId}`);
    }
    
    // æ£€æŸ¥èµ„æºæ¶ˆè€—
    if (!this.canAffordSkill(caster, skill)) {
      throw new Error(`Insufficient resources for skill: ${skillId}`);
    }
    
    // æ¶ˆè€—èµ„æº
    this.consumeResource(skill.cost.amount);
    
    // æ‰§è¡Œä¸»åŠ¨æ•ˆæœ
    for (const effect of skill.activeEffects || []) {
      await this.applyEffect(caster, targetId, effect, turnType);
    }
    
    // æ£€æŸ¥è¢«åŠ¨è§¦å‘
    this.processPassives(caster, 'ON_SKILL_USED');
  }

  /**
   * åº”ç”¨æ•ˆæœ
   */
  private async applyEffect(
    caster: CharacterInstance, 
    targetId: string, 
    effect: Effect, 
    turnType: TurnType
  ): Promise<void> {
    const targets = this.resolveTargets(caster, targetId, effect.target);
    
    switch (effect.type) {
      case 'DAMAGE':
        for (const target of targets) {
          const damage = DamageCalculator.calculateDamage(
            caster, 
            target, 
            effect.damageMultiplier || 1
          );
          target.takeDamage(damage);
          this.eventBus.emit('DAMAGE_DEALT', { caster, target, damage });
        }
        break;
        
      case 'MODIFY_ACTION_BAR':
        const amount = effect.amount || 0;
        for (const target of targets) {
          this.turnManager.modifyActionBar(target, amount);
        }
        break;
        
      case 'APPLY_STATUS':
        for (const target of targets) {
          if (effect.statusId) {
            target.addStatus(effect.statusId, effect.duration);
          }
        }
        break;
        
      // ... å…¶ä»–æ•ˆæœç±»å‹
    }
  }

  // ==================== ç§æœ‰è¾…åŠ©æ–¹æ³• ====================
  
  private createInitialBattleState(
    playerTeam: CharacterDefinition[], 
    enemyTeam: CharacterDefinition[]
  ): BattleState {
    const players = playerTeam.map(char => this.createCharacterInstance(char, 'PLAYER'));
    const enemies = enemyTeam.map(char => this.createCharacterInstance(char, 'ENEMY'));
    
    return {
      battleId: generateBattleId(),
      round: 1,
      players,
      enemies,
      activeCharacterId: null,
      resourceManager: new ResourceManagerImpl(),
      result: 'IN_PROGRESS'
    };
  }
  
  private notifyStateChange(): void {
    this.onStateChange?.(this.state);
  }
  
  // ... å…¶ä»–ç§æœ‰æ–¹æ³•
}
```

### 6.2 å›åˆç®¡ç†å™¨

**`src/core/battle/TurnManager.ts`**

```typescript
import type { CharacterInstance } from '../types/battle';

/**
 * å›åˆç®¡ç†å™¨
 * è´Ÿè´£å¤æ‚çš„è¡ŒåŠ¨æ¡æœºåˆ¶
 */
export class TurnManager {
  private characters: CharacterInstance[];
  private globalFastestSpeed: number;

  constructor(allCharacters: CharacterInstance[]) {
    this.characters = allCharacters;
    this.globalFastestSpeed = this.calculateGlobalFastestSpeed();
    this.initializeActionBars();
  }

  /**
   * è®¡ç®—å…¨åœºä¸€é€Ÿ
   */
  private calculateGlobalFastestSpeed(): number {
    return Math.max(...this.characters.map(char => char.currentStats.SPD));
  }

  /**
   * åˆå§‹åŒ–è¡ŒåŠ¨æ¡ä½ç½®
   */
  private initializeActionBars(): void {
    for (const char of this.characters) {
      char.actionBarPosition = char.currentStats.SPD;
    }
  }

  /**
   * ä¿®æ”¹è¡ŒåŠ¨æ¡ (æ¨æ‹‰æ¡)
   * @param target ç›®æ ‡è§’è‰²
   * @param percentage æ¨æ‹‰æ¡æ¯”ä¾‹ (-1.0 åˆ° 1.0)
   */
  public modifyActionBar(target: CharacterInstance, percentage: number): void {
    const changeAmount = this.globalFastestSpeed * percentage;
    target.actionBarPosition += changeAmount;
    
    // è¾¹ç•Œæ£€æŸ¥
    if (target.actionBarPosition < 0) {
      target.actionBarPosition = 0;
    }
    if (target.actionBarPosition > this.globalFastestSpeed) {
      target.actionBarPosition = this.globalFastestSpeed;
    }
  }

  /**
   * è·å–ä¸‹ä¸€ä¸ªè¡ŒåŠ¨çš„è§’è‰²
   */
  public getNextTurn(): CharacterInstance | null {
    let nextChar: CharacterInstance | null = null;
    let minTimeToEndpoint = Infinity;

    for (const char of this.characters) {
      if (char.isDead) continue;

      const distance = this.globalFastestSpeed - char.actionBarPosition;
      
      if (distance <= 0) {
        // å·²åœ¨ç»ˆç‚¹ï¼Œä¼˜å…ˆé€‰æ‹©
        return char;
      }

      // è®¡ç®—åˆ°è¾¾ç»ˆç‚¹æ‰€éœ€æ—¶é—´
      const currentSpd = char.currentStats.SPD + this.getSpeedBuffs(char);
      const time = distance / currentSpd;

      if (time < minTimeToEndpoint) {
        minTimeToEndpoint = time;
        nextChar = char;
      }
    }

    if (nextChar) {
      // é‡ç½®è¡ŒåŠ¨æ¡ä½ç½®
      nextChar.actionBarPosition = 0;
    }

    return nextChar;
  }

  /**
   * è·å–è§’è‰²é€Ÿåº¦Buffæ€»å’Œ
   */
  private getSpeedBuffs(character: CharacterInstance): number {
    return character.statuses
      .filter(status => status.type === 'SPD_UP')
      .reduce((total, status) => total + (status.effect?.value || 0), 0);
  }

  /**
   * æ¨è¿›æ‰€æœ‰è§’è‰²è¡ŒåŠ¨æ¡ (ç”¨äºæ—¶é—´æ¨è¿›)
   */
  public advanceActionBars(timeElapsed: number): void {
    for (const char of this.characters) {
      if (char.isDead) continue;
      
      const currentSpd = char.currentStats.SPD + this.getSpeedBuffs(char);
      char.actionBarPosition += currentSpd * timeElapsed;
    }
  }
}
```

---

## 7. çŠ¶æ€åŒæ­¥ä¸UIæ¡¥æ¥å±‚

### 7.1 è®¾è®¡åŸåˆ™

**æ ¸å¿ƒçº¦æŸï¼š**
1. **UIç»„ä»¶ç¦æ­¢ç›´æ¥ä¿®æ”¹BattleState**
2. **æ‰€æœ‰çŠ¶æ€å˜æ›´å¿…é¡»é€šè¿‡BattleEngine**
3. **çŠ¶æ€æ›´æ–°ä½¿ç”¨ä¸å¯å˜æ•°æ®æ¨¡å¼**
4. **UIæ¡¥æ¥å±‚é€‚é…ä¸åŒUIæ¡†æ¶**

### 7.2 é€šç”¨æ¡¥æ¥æ¥å£

**`src/ui-bridge/common/BattleStateAdapter.ts`**

```typescript
import type { BattleState } from '../../core/types/battle';

/**
 * æˆ˜æ–—çŠ¶æ€é€‚é…å™¨æ¥å£
 * ä¸åŒUIæ¡†æ¶éœ€è¦å®ç°çš„é€šç”¨æ¥å£
 */
export interface BattleStateAdapter {
  /**
   * è·å–å½“å‰æˆ˜æ–—çŠ¶æ€
   */
  getCurrentState(): BattleState | null;
  
  /**
   * è®¢é˜…çŠ¶æ€å˜åŒ–
   */
  subscribe(callback: (state: BattleState) => void): () => void;
  
  /**
   * æ‰§è¡Œç©å®¶åŠ¨ä½œ
   */
  executePlayerAction(skillId: string, targetId: string): Promise<void>;
  
  /**
   * å¼€å§‹æˆ˜æ–—
   */
  startBattle(playerTeam: any[], enemyTeam: any[]): Promise<void>;
}

/**
 * çŠ¶æ€å˜åŒ–äº‹ä»¶
 */
export interface StateChangeEvent {
  type: 'STATE_CHANGED' | 'ACTION_REQUIRED' | 'BATTLE_ENDED';
  payload: any;
}
```

### 7.3 Reacté€‚é…å™¨å®ç°

**`src/ui-bridge/react/BattleAdapter.ts`**

```typescript
import { useState, useEffect, useCallback } from 'react';
import type { BattleState } from '../../core/types/battle';
import { BattleEngine } from '../../core/battle/BattleEngine';
import type { CharacterDefinition } from '../../core/types/definitions';

/**
 * React UIæ¡¥æ¥é€‚é…å™¨
 * è´Ÿè´£BattleEngineä¸ReactçŠ¶æ€çš„åŒæ­¥
 */
export class ReactBattleAdapter {
  private battleEngine: BattleEngine | null = null;
  private subscribers: Set<(state: BattleState) => void> = new Set();

  constructor() {
    // è®¢é˜…å¼•æ“çŠ¶æ€å˜åŒ–
  }

  /**
   * å¼€å§‹æˆ˜æ–—
   */
  public async startBattle(
    playerTeam: CharacterDefinition[],
    enemyTeam: CharacterDefinition[]
  ): Promise<void> {
    this.battleEngine = new BattleEngine(
      playerTeam,
      enemyTeam,
      (newState) => this.notifyStateChange(newState)
    );
    
    await this.battleEngine.startBattle();
  }

  /**
   * æ‰§è¡Œç©å®¶åŠ¨ä½œ
   */
  public async executePlayerAction(
    skillId: string, 
    targetId: string
  ): Promise<void> {
    if (!this.battleEngine) {
      throw new Error('Battle not started');
    }
    
    const activeChar = this.getActiveCharacter();
    if (!activeChar) {
      throw new Error('No active character');
    }
    
    await this.battleEngine.executeAction(
      activeChar, 
      skillId, 
      targetId, 
      'NORMAL'
    );
  }

  /**
   * è®¢é˜…çŠ¶æ€å˜åŒ– (é€‚é…React hooks)
   */
  public useBattleState() {
    const [battleState, setBattleState] = useState<BattleState | null>(null);

    useEffect(() => {
      const unsubscribe = this.subscribe(setBattleState);
      return unsubscribe;
    }, []);

    return battleState;
  }

  /**
   * è®¢é˜…çŠ¶æ€å˜åŒ–
   */
  public subscribe(callback: (state: BattleState) => void): () => void {
    this.subscribers.add(callback);
    return () => {
      this.subscribers.delete(callback);
    };
  }

  /**
   * é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…çŠ¶æ€å˜åŒ–
   */
  private notifyStateChange(state: BattleState): void {
    // ä½¿ç”¨ä¸å¯å˜æ•°æ®æ¨¡å¼
    const newState = { ...state };
    
    for (const subscriber of this.subscribers) {
      subscriber(newState);
    }
  }

  private getActiveCharacter() {
    const state = this.getCurrentState();
    if (!state || !state.activeCharacterId) return null;
    
    return [...state.players, ...state.enemies]
      .find(char => char.instanceId === state.activeCharacterId);
  }

  private getCurrentState(): BattleState | null {
    return this.subscribers.size > 0 ? 
      // è¿”å›æœ€æ–°çŠ¶æ€ (å®é™…å®ç°éœ€è¦å­˜å‚¨çŠ¶æ€)
      null : null;
  }
}
```

**`src/ui-bridge/react/hooks/useBattleStore.ts`**

```typescript
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import type { BattleState } from '../../../core/types/battle';
import { ReactBattleAdapter } from '../BattleAdapter';

/**
 * Zustandæˆ˜æ–—çŠ¶æ€å­˜å‚¨
 * æä¾›Reactç»„ä»¶ä½¿ç”¨çš„çŠ¶æ€ç®¡ç†
 */
interface BattleStore {
  // çŠ¶æ€
  battleState: BattleState | null;
  isLoading: boolean;
  error: string | null;
  
  // æ“ä½œ
  startBattle: (playerTeam: any[], enemyTeam: any[]) => Promise<void>;
  executePlayerAction: (skillId: string, targetId: string) => Promise<void>;
  resetBattle: () => void;
}

export const useBattleStore = create<BattleStore>()(
  subscribeWithSelector((set, get) => ({
    // åˆå§‹çŠ¶æ€
    battleState: null,
    isLoading: false,
    error: null,
    
    // é€‚é…å™¨å®ä¾‹
    adapter: new ReactBattleAdapter(),
    
    // å¼€å§‹æˆ˜æ–—
    startBattle: async (playerTeam, enemyTeam) => {
      set({ isLoading: true, error: null });
      
      try {
        await get().adapter.startBattle(playerTeam, enemyTeam);
      } catch (error) {
        set({ error: error instanceof Error ? error.message : 'Unknown error' });
      } finally {
        set({ isLoading: false });
      }
    },
    
    // æ‰§è¡Œç©å®¶åŠ¨ä½œ
    executePlayerAction: async (skillId, targetId) => {
      try {
        await get().adapter.executePlayerAction(skillId, targetId);
      } catch (error) {
        set({ error: error instanceof Error ? error.message : 'Action failed' });
      }
    },
    
    // é‡ç½®æˆ˜æ–—
    resetBattle: () => {
      set({ 
        battleState: null, 
        isLoading: false, 
        error: null 
      });
    }
  }))
);

// çŠ¶æ€è®¢é˜…
useBattleStore.subscribe(
  (state) => state.battleState,
  (battleState) => {
    // è¿™é‡Œå¯ä»¥æ·»åŠ æ—¥å¿—æˆ–åˆ†æé€»è¾‘
    console.log('Battle state changed:', battleState);
  }
);
```

### 7.4 Vueé€‚é…å™¨ (è§„åˆ’)

**`src/ui-bridge/vue/BattleAdapter.ts` (æœªæ¥å®ç°)**

```typescript
/**
 * Vue 3 é€‚é…å™¨ (Pinia)
 * æœªæ¥æ‰©å±•æ”¯æŒVueæ¡†æ¶
 */
export class VueBattleAdapter {
  // Vueç‰¹å®šçš„å®ç°
  // ä½¿ç”¨Piniaè¿›è¡ŒçŠ¶æ€ç®¡ç†
}
```

---

## 8. å•å…ƒæµ‹è¯•é©±åŠ¨å¼€å‘

### 8.1 TDDåŸåˆ™

**ä¸¥æ ¼éµå¾ªæµ‹è¯•ä¼˜å…ˆå¼€å‘ï¼š**
1. ç¼–å†™å¤±è´¥çš„æµ‹è¯•ç”¨ä¾‹
2. ç¼–å†™æœ€å°å®ç°ä½¿æµ‹è¯•é€šè¿‡
3. é‡æ„ä»£ç 
4. é‡å¤å¾ªç¯

### 8.2 æˆ˜æ–—ç³»ç»Ÿæµ‹è¯•ç”¨ä¾‹

**`tests/unit/core/battle/TurnManager.test.ts`**

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { TurnManager } from '../../../../src/core/battle/TurnManager';
import type { CharacterInstance } from '../../../../src/core/types/battle';

/**
 * å›åˆç®¡ç†å™¨æµ‹è¯•
 * åŒ…å«å¤æ‚çš„è¡ŒåŠ¨æ¡æœºåˆ¶æµ‹è¯•ç”¨ä¾‹
 */
describe('TurnManager', () => {
  let turnManager: TurnManager;
  let mockCharacters: CharacterInstance[];

  beforeEach(() => {
    // åˆ›å»ºæµ‹è¯•è§’è‰²å®ä¾‹
    mockCharacters = [
      createMockCharacter('char_A', 100), // é€Ÿåº¦100
      createMockCharacter('char_B', 200)  // é€Ÿåº¦200 (å…¨åœºä¸€é€Ÿ)
    ];
    
    turnManager = new TurnManager(mockCharacters);
  });

  describe('è¡ŒåŠ¨æ¡æœºåˆ¶', () => {
    it('åº”è¯¥æ­£ç¡®è®¡ç®—å…¨åœºä¸€é€Ÿ', () => {
      expect(turnManager['globalFastestSpeed']).toBe(200);
    });

    it('åº”è¯¥æ­£ç¡®åˆå§‹åŒ–è¡ŒåŠ¨æ¡ä½ç½®', () => {
      expect(mockCharacters[0].actionBarPosition).toBe(100);
      expect(mockCharacters[1].actionBarPosition).toBe(200);
    });

    it('é€Ÿåº¦100çš„è§’è‰²åº”ä½äºè¡ŒåŠ¨æ¡50%å¤„', () => {
      expect(mockCharacters[0].actionBarPosition).toBe(100); // 100/200 = 50%
    });

    it('é€Ÿåº¦200çš„è§’è‰²åº”ä½äºè¡ŒåŠ¨æ¡100%å¤„', () => {
      expect(mockCharacters[1].actionBarPosition).toBe(200); // 200/200 = 100%
    });
  });

  describe('æ¨æ‹‰æ¡æœºåˆ¶', () => {
    it('åº”è¯¥æ­£ç¡®æ‰§è¡Œæ‹‰æ¡30%', () => {
      const target = mockCharacters[0];
      const originalPosition = target.actionBarPosition;
      
      turnManager.modifyActionBar(target, 0.3); // æ‹‰æ¡30%
      
      const expectedChange = 200 * 0.3; // å…¨åœºä¸€é€Ÿ Ã— 30%
      expect(target.actionBarPosition).toBe(originalPosition + expectedChange);
    });

    it('ä¸åº”è¯¥è®©è¡ŒåŠ¨æ¡ä½ç½®ä½äº0', () => {
      const target = mockCharacters[0];
      target.actionBarPosition = 10;
      
      turnManager.modifyActionBar(target, -0.2); // æ¨æ¡20%
      
      expect(target.actionBarPosition).toBe(0);
    });
  });

  describe('å›åˆé¡ºåº', () => {
    it('åº”è¯¥ä¼˜å…ˆé€‰æ‹©å·²åœ¨ç»ˆç‚¹çš„è§’è‰²', () => {
      const result = turnManager.getNextTurn();
      
      // char_Båœ¨ç»ˆç‚¹ï¼Œä¼˜å…ˆé€‰æ‹©
      expect(result?.instanceId).toBe('char_B');
    });

    it('é€‰æ‹©è§’è‰²ååº”è¯¥é‡ç½®å…¶è¡ŒåŠ¨æ¡', () => {
      const result = turnManager.getNextTurn();
      
      expect(result?.actionBarPosition).toBe(0);
    });
  });

  describe('å¤æ‚åœºæ™¯æµ‹è¯•', () => {
    it('å¤šè§’è‰²åŒæ—¶åœ¨ç»ˆç‚¹çš„å¤„ç†', () => {
      // æ¨¡æ‹Ÿä¸¤ä¸ªè§’è‰²éƒ½åœ¨ç»ˆç‚¹
      mockCharacters[0].actionBarPosition = 200;
      mockCharacters[1].actionBarPosition = 200;
      
      const result = turnManager.getNextTurn();
      
      // åº”è¯¥è¿”å›å…¶ä¸­ä¸€ä¸ªï¼Œå…·ä½“é€‰æ‹©é€»è¾‘éœ€è¦è¿›ä¸€æ­¥å®šä¹‰
      expect(result).toBeDefined();
    });
  });
});

// è¾…åŠ©å‡½æ•°
function createMockCharacter(id: string, speed: number): CharacterInstance {
  return {
    instanceId: id,
    characterId: id,
    currentStats: { SPD: speed } as any,
    actionBarPosition: speed,
    statuses: [],
    isDead: false,
    equipment: []
  };
}
```

**`tests/unit/core/battle/DamageCalculator.test.ts`**

```typescript
import { describe, it, expect } from 'vitest';
import { DamageCalculator } from '../../../../src/core/battle/DamageCalculator';
import type { CharacterInstance } from '../../../../src/core/types/battle';

/**
 * ä¼¤å®³è®¡ç®—å™¨æµ‹è¯•
 * åŒ…å«è¾¹ç¼˜æƒ…å†µå¤„ç†
 */
describe('DamageCalculator', () => {
  describe('åŸºç¡€ä¼¤å®³è®¡ç®—', () => {
    it('åº”è¯¥æ­£ç¡®è®¡ç®—åŸºç¡€ä¼¤å®³', () => {
      const caster = createMockCaster({
        ATK: 1000,
        CRIT_DMG: 1.5
      });
      
      const target = createMockTarget({
        DEF: 500
      });
      
      const damage = DamageCalculator.calculateDamage(caster, target, 1.0);
      
      expect(damage).toBeGreaterThan(0);
      expect(typeof damage).toBe('number');
    });

    it('åº”è¯¥å¤„ç†é˜²å¾¡ä¸º0çš„æƒ…å†µ', () => {
      const caster = createMockCaster({ ATK: 1000 });
      const target = createMockTarget({ DEF: 0 });
      
      const damage = DamageCalculator.calculateDamage(caster, target, 1.0);
      
      // é˜²å¾¡ä¸º0æ—¶åº”è¯¥é€ æˆæ›´é«˜ä¼¤å®³
      expect(damage).toBeGreaterThan(500); // ä¿å®ˆä¼°è®¡
    });
  });

  describe('é˜²å¾¡ç©¿é€æµ‹è¯•', () => {
    it('åº”è¯¥æ­£ç¡®å¤„ç†æ— è§†é˜²å¾¡ç™¾åˆ†æ¯”', () => {
      const caster = createMockCaster({
        ATK: 1000,
        IGNORE_DEF_P: 0.5 // 50%æ— è§†é˜²å¾¡
      });
      
      const target = createMockTarget({ DEF: 1000 });
      
      const damage = DamageCalculator.calculateDamage(caster, target, 1.0);
      
      // 50%æ— è§†é˜²å¾¡åº”è¯¥æ¯”0%æ— è§†é˜²å¾¡é€ æˆæ›´å¤šä¼¤å®³
      expect(damage).toBeGreaterThan(800); // ä¿å®ˆä¼°è®¡
    });

    it('åº”è¯¥å¤„ç†é˜²å¾¡ä¸ºè´Ÿæ•°çš„æƒ…å†µ', () => {
      const caster = createMockCaster({
        ATK: 1000,
        IGNORE_DEF_FLAT: 600
      });
      
      const target = createMockTarget({ DEF: 500 });
      
      // 500 - 600 = -100 < 0ï¼Œåº”è¯¥è§†ä¸º0
      const damage = DamageCalculator.calculateDamage(caster, target, 1.0);
      
      expect(damage).toBeGreaterThan(1000); // é˜²å¾¡ä¸ºè´Ÿåº”è¯¥å¢ä¼¤
    });
  });

  describe('Buffå åŠ æµ‹è¯•', () => {
    it('åŒç±»Buffåº”è¯¥æ˜¯åŠ æ³•å åŠ ', () => {
      const caster1 = createMockCaster({
        ATK: 1000,
        ATK_P: 0.2 // 20%æ”»å‡»åŠ æˆ
      });
      
      const caster2 = createMockCaster({
        ATK: 1000,
        ATK_P: 0.3 // 30%æ”»å‡»åŠ æˆ
      });
      
      const target = createMockTarget({ DEF: 500 });
      
      const damage1 = DamageCalculator.calculateDamage(caster1, target, 1.0);
      const damage2 = DamageCalculator.calculateDamage(caster2, target, 1.0);
      
      // 30%åº”è¯¥æ¯”20%é€ æˆæ›´å¤šä¼¤å®³
      expect(damage2).toBeGreaterThan(damage1);
    });
  });

  describe('æš´å‡»ä¼¤å®³æµ‹è¯•', () => {
    it('åº”è¯¥æ­£ç¡®åº”ç”¨æš´å‡»ä¼¤å®³', () => {
      const normalCaster = createMockCaster({
        ATK: 1000,
        CRIT_DMG: 1.5
      });
      
      const highCritCaster = createMockCaster({
        ATK: 1000,
        CRIT_DMG: 2.0
      });
      
      const target = createMockTarget({ DEF: 500 });
      
      const normalDamage = DamageCalculator.calculateDamage(normalCaster, target, 1.0);
      const highCritDamage = DamageCalculator.calculateDamage(highCritCaster, target, 1.0);
      
      expect(highCritDamage).toBeGreaterThan(normalDamage);
    });
  });
});

// è¾…åŠ©å‡½æ•°
function createMockCaster(stats: any): CharacterInstance {
  return {
    instanceId: 'caster',
    characterId: 'caster',
    currentStats: { SPD: 100, ...stats },
    actionBarPosition: 0,
    statuses: [],
    isDead: false,
    equipment: []
  };
}

function createMockTarget(stats: any): CharacterInstance {
  return {
    instanceId: 'target',
    characterId: 'target',
    currentStats: { SPD: 100, ...stats },
    actionBarPosition: 0,
    statuses: [],
    isDead: false,
    equipment: []
  };
}
```

---

## 9. æ’ä»¶ç³»ç»Ÿæ¶æ„

### 9.1 æ’ä»¶ç³»ç»Ÿè®¾è®¡

**æ ¸å¿ƒåŸåˆ™ï¼š**
- **çƒ­æ’æ‹”ï¼š** è¿è¡Œæ—¶åŠ¨æ€åŠ è½½/å¸è½½æ’ä»¶
- **ç±»å‹å®‰å…¨ï¼š** ä¸¥æ ¼çš„æ’ä»¶æ¥å£éªŒè¯
- **ç‰ˆæœ¬æ§åˆ¶ï¼š** æ’ä»¶ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥

### 9.2 æ’ä»¶åŠ è½½å™¨

**`src/core/plugin-system/PluginManager.ts`**

```typescript
import type { 
  CharacterDefinition, 
  SkillDefinition, 
  EquipmentDefinition, 
  StatusDefinition 
} from '../types/definitions';
import { PluginLoader } from './PluginLoader';
import { PluginValidator } from './validators/PluginValidator';

/**
 * æ’ä»¶ç®¡ç†å™¨
 * è´Ÿè´£æ’ä»¶çš„åŠ è½½ã€éªŒè¯ã€ç®¡ç†
 */
export class PluginManager {
  private loader: PluginLoader;
  private validator: PluginValidator;
  
  // æ’ä»¶æ•°æ®åº“
  private characters: Map<string, CharacterDefinition> = new Map();
  private skills: Map<string, SkillDefinition> = new Map();
  private equipment: Map<string, EquipmentDefinition> = new Map();
  private statuses: Map<string, StatusDefinition> = new Map();
  
  // æ’ä»¶å…ƒæ•°æ®
  private pluginMetadata: Map<string, PluginMetadata> = new Map();

  constructor() {
    this.loader = new PluginLoader();
    this.validator = new PluginValidator();
  }

  /**
   * åŠ è½½æ‰€æœ‰æ’ä»¶
   */
  public async loadAllPlugins(): Promise<void> {
    try {
      const pluginModules = await this.loader.loadAllModules();
      
      for (const [path, module] of pluginModules) {
        await this.processPluginModule(path, module);
      }
      
      console.log(`Loaded ${this.characters.size} characters, ${this.skills.size} skills`);
    } catch (error) {
      console.error('Failed to load plugins:', error);
      throw error;
    }
  }

  /**
   * åŠ è½½å•ä¸ªæ’ä»¶æ¨¡å—
   */
  private async processPluginModule(path: string, module: any): Promise<void> {
    for (const [exportName, exportedItem] of Object.entries(module)) {
      if (this.isValidPlugin(exportedItem)) {
        const metadata = this.extractMetadata(exportedItem, path);
        
        // éªŒè¯æ’ä»¶
        if (!this.validator.validatePlugin(exportedItem)) {
          console.warn(`Invalid plugin skipped: ${exportName}`);
          continue;
        }
        
        // æ³¨å†Œæ’ä»¶
        this.registerPlugin(exportedItem, metadata);
      }
    }
  }

  /**
   * æ³¨å†Œæ’ä»¶åˆ°æ•°æ®åº“
   */
  private registerPlugin(plugin: any, metadata: PluginMetadata): void {
    this.pluginMetadata.set(plugin.id, metadata);
    
    switch (metadata.type) {
      case 'CHARACTER':
        this.characters.set(plugin.id, plugin);
        break;
      case 'SKILL':
        this.skills.set(plugin.id, plugin);
        break;
      case 'EQUIPMENT':
        this.equipment.set(plugin.id, plugin);
        break;
      case 'STATUS':
        this.statuses.set(plugin.id, plugin);
        break;
    }
  }

  /**
   * è·å–æ’ä»¶
   */
  public getCharacter(id: string): CharacterDefinition | undefined {
    return this.characters.get(id);
  }
  
  public getSkill(id: string): SkillDefinition | undefined {
    return this.skills.get(id);
  }
  
  public getEquipment(id: string): EquipmentDefinition | undefined {
    return this.equipment.get(id);
  }
  
  public getStatus(id: string): StatusDefinition | undefined {
    return this.statuses.get(id);
  }

  /**
   * è·å–æ‰€æœ‰æ’ä»¶
   */
  public getAllCharacters(): CharacterDefinition[] {
    return Array.from(this.characters.values());
  }
  
  public getAllSkills(): SkillDefinition[] {
    return Array.from(this.skills.values());
  }

  private isValidPlugin(item: any): boolean {
    return item && 
           typeof item === 'object' && 
           typeof item.id === 'string' && 
           item.id.length > 0;
  }

  private extractMetadata(plugin: any, path: string): PluginMetadata {
    return {
      id: plugin.id,
      type: this.determinePluginType(plugin),
      path,
      version: plugin.version || '1.0.0',
      author: plugin.author || 'Unknown',
      loadTime: Date.now()
    };
  }

  private determinePluginType(plugin: any): PluginType {
    // æ ¹æ®æ’ä»¶ç»“æ„æ¨æ–­ç±»å‹
    if (plugin.growthValues && plugin.skills) return 'CHARACTER';
    if (plugin.cost && (plugin.activeEffects || plugin.passiveListeners)) return 'SKILL';
    if (plugin.setId && plugin.slot) return 'EQUIPMENT';
    if (plugin.type && plugin.statModifiers) return 'STATUS';
    
    return 'UNKNOWN';
  }
}

interface PluginMetadata {
  id: string;
  type: PluginType;
  path: string;
  version: string;
  author: string;
  loadTime: number;
}

type PluginType = 'CHARACTER' | 'SKILL' | 'EQUIPMENT' | 'STATUS' | 'UNKNOWN';
```

**`src/core/plugin-system/PluginLoader.ts`**

```typescript
/**
 * æ’ä»¶åŠ è½½å™¨
 * ä½¿ç”¨ Vite çš„ import.meta.glob åŠ¨æ€åŠ è½½æ’ä»¶
 */
export class PluginLoader {
  /**
   * åŠ è½½æ‰€æœ‰æ’ä»¶æ¨¡å—
   */
  public async loadAllModules(): Promise<Record<string, any>> {
    const modules = import.meta.glob('../plugins/**/*.ts', { 
      eager: true,
      import: 'default' 
    });
    
    return modules;
  }

  /**
   * åŠ è½½ç‰¹å®šç±»å‹æ’ä»¶
   */
  public async loadCharacterModules(): Promise<Record<string, CharacterDefinition>> {
    const modules = import.meta.glob('../plugins/characters/*.ts', { 
      eager: true 
    });
    
    return this.extractModules(modules);
  }

  public async loadSkillModules(): Promise<Record<string, SkillDefinition>> {
    const modules = import.meta.glob('../plugins/skills/*.ts', { 
      eager: true 
    });
    
    return this.extractModules(modules);
  }

  private extractModules(modules: Record<string, any>): Record<string, any> {
    const result: Record<string, any> = {};
    
    for (const [path, module] of Object.entries(modules)) {
      // æå–é»˜è®¤å¯¼å‡º
      if (module.default) {
        result[path] = module.default;
      }
      // ä¹Ÿæ”¯æŒå‘½åå¯¼å‡º
      else {
        result[path] = module;
      }
    }
    
    return result;
  }
}
```

### 9.3 æ’ä»¶éªŒè¯å™¨

**`src/core/plugin-system/validators/PluginValidator.ts`**

```typescript
import type { 
  CharacterDefinition, 
  SkillDefinition, 
  EquipmentDefinition, 
  StatusDefinition 
} from '../../types/definitions';

/**
 * æ’ä»¶éªŒè¯å™¨
 * ç¡®ä¿æ’ä»¶ç¬¦åˆæ¥å£è§„èŒƒ
 */
export class PluginValidator {
  /**
   * éªŒè¯æ’ä»¶æ˜¯å¦åˆæ³•
   */
  public validatePlugin(plugin: any): boolean {
    if (!this.hasRequiredId(plugin)) {
      return false;
    }
    
    // æ ¹æ®ç±»å‹éªŒè¯å…·ä½“ç»“æ„
    if (this.isCharacter(plugin)) {
      return this.validateCharacter(plugin);
    } else if (this.isSkill(plugin)) {
      return this.validateSkill(plugin);
    } else if (this.isEquipment(plugin)) {
      return this.validateEquipment(plugin);
    } else if (this.isStatus(plugin)) {
      return this.validateStatus(plugin);
    }
    
    return false;
  }

  private hasRequiredId(plugin: any): boolean {
    return plugin && 
           typeof plugin.id === 'string' && 
           plugin.id.length > 0 &&
           plugin.id.match(/^[A-Z_0-9]+$/);
  }

  private isCharacter(plugin: any): boolean {
    return plugin.growthValues && plugin.skills;
  }

  private isSkill(plugin: any): boolean {
    return plugin.cost && (plugin.activeEffects || plugin.passiveListeners);
  }

  private isEquipment(plugin: any): boolean {
    return plugin.setId && plugin.slot;
  }

  private isStatus(plugin: any): boolean {
    return plugin.type && plugin.statModifiers;
  }

  private validateCharacter(character: CharacterDefinition): boolean {
    // éªŒè¯å¿…è¦å­—æ®µ
    if (!character.name || !character.assets) {
      return false;
    }
    
    // éªŒè¯æˆé•¿å€¼
    const requiredStats = ['hp', 'atk', 'def', 'spd', 'crit', 'critDmg'];
    for (const stat of requiredStats) {
      if (typeof character.growthValues[stat] !== 'number') {
        return false;
      }
    }
    
    // éªŒè¯æŠ€èƒ½æ•°ç»„
    if (!Array.isArray(character.skills) || character.skills.length !== 3) {
      return false;
    }
    
    return true;
  }

  private validateSkill(skill: SkillDefinition): boolean {
    // éªŒè¯æ¶ˆè€—é…ç½®
    if (!skill.cost || skill.cost.type !== 'BATTLE_RESOURCE') {
      return false;
    }
    
    if (typeof skill.cost.amount !== 'number' || skill.cost.amount < 0) {
      return false;
    }
    
    // éªŒè¯æ•ˆæœæ•°ç»„
    if (skill.activeEffects) {
      for (const effect of skill.activeEffects) {
        if (!this.validateEffect(effect)) {
          return false;
        }
      }
    }
    
    return true;
  }

  private validateEquipment(equipment: EquipmentDefinition): boolean {
    // éªŒè¯è£…å¤‡ä½
    if (typeof equipment.slot !== 'number' || equipment.slot < 1 || equipment.slot > 6) {
      return false;
    }
    
    return true;
  }

  private validateStatus(status: StatusDefinition): boolean {
    // éªŒè¯çŠ¶æ€ç±»å‹
    // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´ä¸¥æ ¼çš„æšä¸¾éªŒè¯
    
    return true;
  }

  private validateEffect(effect: any): boolean {
    // éªŒè¯æ•ˆæœç±»å‹
    const validTypes = ['DAMAGE', 'HEAL', 'APPLY_STATUS', 'MODIFY_ACTION_BAR'];
    if (!validTypes.includes(effect.type)) {
      return false;
    }
    
    // éªŒè¯ç›®æ ‡ç±»å‹
    const validTargets = ['SELF', 'TARGET', 'ALL_ALLIES', 'ALL_ENEMIES'];
    if (!validTargets.includes(effect.target)) {
      return false;
    }
    
    return true;
  }
}
```

### 9.4 å…·ä½“æ’ä»¶æ–‡ä»¶æ¨¡æ¿

**è§’è‰²æ’ä»¶ç¤ºä¾‹ï¼š** `src/plugins/characters/character_1001.ts`

```typescript
import type { CharacterDefinition } from '../../core/types/definitions';

/**
 * ç¤ºä¾‹è§’è‰²æ’ä»¶
 * è§’è‰²ID: CHAR_1001
 */
export const character_1001: CharacterDefinition = {
  id: "CHAR_1001",
  name: "é£é“ƒå®ˆæŠ¤è€…", // å…è®¸ç¡¬ç¼–ç åç§°
  
  assets: {
    avatar: "/assets/characters/char_1001_avatar.png",
    portrait: "/assets/characters/char_1001_portrait.png"
  },
  
  // æˆé•¿å€¼ç³»ç»Ÿ (æ¯çº§å¢é•¿çš„åŸºç¡€æ•°å€¼)
  growthValues: {
    hp: 320.5,      // ç”Ÿå‘½æˆé•¿
    atk: 185.2,     // æ”»å‡»æˆé•¿
    def: 95.8,      // é˜²å¾¡æˆé•¿
    spd: 118,       // é€Ÿåº¦ (é€šå¸¸å›ºå®š)
    crit: 0.08,     // æš´å‡»ç‡æˆé•¿ (8%)
    critDmg: 1.65   // æš´å‡»ä¼¤å®³æˆé•¿ (165%)
  },
  
  // æŠ€èƒ½IDæ•°ç»„ (æŒ‰ä¼˜å…ˆçº§æ’åº)
  skills: ["SKILL_1001", "SKILL_1002", "SKILL_1003"]
};
```

**æŠ€èƒ½æ’ä»¶ç¤ºä¾‹ï¼š** `src/plugins/skills/skill_1001.ts`

```typescript
import type { SkillDefinition } from '../../core/types/definitions';
import { TERMS } from '../../core/config/terms';

/**
 * ç¤ºä¾‹æŠ€èƒ½æ’ä»¶
 * æŠ€èƒ½ID: SKILL_1001
 */
export const skill_1001: SkillDefinition = {
  id: "SKILL_1001",
  name: "é£åˆƒæœ¯", // æŠ€èƒ½åç§°
  
  // æŠ€èƒ½æ¶ˆè€— (ä½¿ç”¨æœ¯è¯­é…ç½®)
  cost: {
    type: "BATTLE_RESOURCE",
    amount: 3
  },
  
  // ä¸»åŠ¨æ•ˆæœ
  activeEffects: [
    {
      type: "DAMAGE",
      target: "TARGET",
      damageMultiplier: 1.2 // 120%æ”»å‡»ä¼¤å®³
    },
    {
      type: "MODIFY_ACTION_BAR",
      target: "SELF", 
      amount: 0.2 // æ‹‰æ¡20%
    }
  ],
  
  // è¢«åŠ¨ç›‘å¬
  passiveListeners: [
    {
      event: "ON_TURN_START",
      effects: [
        {
          type: "APPLY_STATUS",
          target: "SELF",
          statusId: "STATUS_WIND_SHIELD",
          duration: 1
        }
      ]
    }
  ],
  
  // æŠ€èƒ½æè¿° (ç”¨äºUIæ˜¾ç¤º)
  description: "å¯¹æ•Œæ–¹ç›®æ ‡é€ æˆ120%æ”»å‡»çš„ä¼¤å®³ï¼Œå¹¶æå‡è‡ªèº«è¡ŒåŠ¨æ¡20%ï¼Œè·å¾—1å±‚é£ç›¾æ•ˆæœã€‚"
};
```

**è£…å¤‡æ’ä»¶ç¤ºä¾‹ï¼š** `src/plugins/equipment/equip_2001.ts`

```typescript
import type { EquipmentDefinition } from '../../core/types/definitions';

/**
 * ç¤ºä¾‹è£…å¤‡æ’ä»¶
 * è£…å¤‡ID: EQUIP_2001
 */
export const equip_2001: EquipmentDefinition = {
  id: "EQUIP_2001",
  name: "é£è¯­ä¹‹åˆƒ",
  setId: "WIND_SET_01",
  slot: 1, // æ­¦å™¨ä½
  
  // åŸºç¡€å±æ€§
  baseStats: {
    ATK: 45,      // +45 æ”»å‡»åŠ›
    ATK_P: 0.08   // +8% æ”»å‡»åŠ›
  },
  
  // å¯èƒ½çš„å‰¯å±æ€§ (ç”¨äºéšæœºç”Ÿæˆ)
  possibleSecondaryStats: [
    "ATK_P",    // æ”»å‡»åŠ æˆ%
    "CRIT",     // æš´å‡»ç‡
    "SPD",      // é€Ÿåº¦
    "ATK"       // æ”»å‡»å›ºå®šå€¼
  ]
};
```

**çŠ¶æ€æ’ä»¶ç¤ºä¾‹ï¼š** `src/plugins/statuses/status_3001.ts`

```typescript
import type { StatusDefinition } from '../../core/types/definitions';

/**
 * ç¤ºä¾‹çŠ¶æ€æ’ä»¶
 * çŠ¶æ€ID: STATUS_WIND_SHIELD
 */
export const status_3001: StatusDefinition = {
  id: "STATUS_WIND_SHIELD",
  name: "é£ç›¾",
  type: "DEF_UP",
  
  // æŒç»­1å›åˆ
  duration: 1,
  
  // çŠ¶æ€æ•ˆæœ
  statModifiers: {
    DEF_P: 0.15, // é˜²å¾¡æå‡15%
    SPD: 5       // é€Ÿåº¦+5
  },
  
  // å›åˆå¼€å§‹æ—¶è§¦å‘
  onTurnStart: [
    {
      type: "MODIFY_ACTION_BAR",
      target: "SELF",
      amount: 0.1 // è¡ŒåŠ¨æ¡å‰è¿›10%
    }
  ]
};
```

---

## 10. ä¼¤å®³å…¬å¼ä¸è¾¹ç•Œå¤„ç†

### 10.1 å®Œæ•´ä¼¤å®³è®¡ç®—

**`src/core/battle/DamageCalculator.ts`**

```typescript
import type { CharacterInstance } from '../types/battle';
import type { StatType } from '../types/definitions';

/**
 * ä¼¤å®³è®¡ç®—å™¨
 * å®ç°ç²¾ç¡®çš„é˜´é˜³å¸ˆä¼¤å®³å…¬å¼
 */
export class DamageCalculator {
  /**
   * ä¸»ä¼¤å®³è®¡ç®—å‡½æ•°
   * @param caster æ–½æ³•è€…
   * @param target ç›®æ ‡
   * @param multiplier æŠ€èƒ½ç³»æ•°
   * @returns è®¡ç®—åçš„ä¼¤å®³å€¼
   */
  static calculateDamage(
    caster: CharacterInstance, 
    target: CharacterInstance, 
    multiplier: number = 1.0
  ): number {
    
    // 1. åŸºç¡€æ”»å‡»åŠ›è®¡ç®—
    const baseAtk = this.calculateBaseStat(caster, StatType.ATK);
    
    // 2. æ”»å‡»å¢ç›Šè®¡ç®—
    const atkBonus = this.calculateStatBonus(caster, StatType.ATK);
    
    // 3. è£…å¤‡æ”»å‡»åŠ›
    const equipmentAtk = this.getEquipmentFlatAttack(caster);
    
    // 4. æœ€ç»ˆæ”»å‡»åŠ›
    const finalAtk = (baseAtk * (1 + atkBonus) + equipmentAtk);
    
    // 5. æš´å‡»ä¼¤å®³
    const critDamage = this.calculateCritDamage(caster);
    
    // 6. ä¼¤å®³å¢ç›Š
    const damageBonus = this.calculateDamageBonus(caster);
    const damageTakenBonus = this.calculateDamageTakenBonus(target);
    
    // 7. é˜²å¾¡è®¡ç®— (åŒ…å«ç©¿é€)
    const defenseValue = this.calculateEffectiveDefense(target, caster);
    
    // 8. æŠ€èƒ½ç³»æ•°
    const skillMultiplier = multiplier;
    
    // 9. æœ€ç»ˆä¼¤å®³è®¡ç®—
    const damage = this.computeFinalDamage(
      finalAtk,
      critDamage,
      damageBonus,
      damageTakenBonus,
      defenseValue,
      skillMultiplier
    );
    
    return Math.max(0, Math.floor(damage));
  }

  /**
   * è®¡ç®—åŸºç¡€æ”»å‡»åŠ› (æˆé•¿å€¼ Ã— æˆé•¿ç‚¹)
   */
  private static calculateBaseAttack(caster: CharacterInstance): number {
    const growthValue = caster.characterId.includes('CHAR_1001') ? 185.2 : 100;
    const level = 40; // TODO: ä»è§’è‰²å®ä¾‹è·å–ç­‰çº§
    const growthPoints = this.getGrowthPoints(level);
    
    return growthValue * growthPoints;
  }

  /**
   * è®¡ç®—æ”»å‡»å¢ç›Š (ç™¾åˆ†æ¯”)
   */
  private static calculateStatBonus(caster: CharacterInstance, statType: StatType): number {
    let bonus = 0;
    
    // åŸºç¡€æ”»å‡»åŠ æˆ
    bonus += caster.currentStats[statType] || 0;
    
    // Buffæ”»å‡»åŠ æˆ
    bonus += this.getBuffBonus(caster, statType);
    
    return bonus;
  }

  /**
   * è®¡ç®—æš´å‡»ä¼¤å®³
   */
  private static calculateCritDamage(caster: CharacterInstance): number {
    const baseCritDmg = caster.currentStats.CRIT_DMG || 1.5;
    
    // æš´å‡»ä¼¤å®³åŠ æˆBuff
    const buffBonus = this.getBuffBonus(caster, 'CRIT_DMG_BONUS');
    
    return baseCritDmg + buffBonus;
  }

  /**
   * è®¡ç®—æœ‰æ•ˆé˜²å¾¡ (è€ƒè™‘ç©¿é€)
   */
  private static calculateEffectiveDefense(
    target: CharacterInstance, 
    caster: CharacterInstance
  ): number {
    const baseDef = target.currentStats.DEF || 0;
    
    // é˜²å¾¡ç™¾åˆ†æ¯”åŠ æˆ/å‡å°‘
    const defBonus = target.currentStats.DEF_P || 0;
    
    // å¿½ç•¥é˜²å¾¡ (å›ºå®šå€¼)
    const ignoreDefFlat = this.getBuffValue(caster, 'IGNORE_DEF_FLAT');
    
    // æ— è§†é˜²å¾¡ (ç™¾åˆ†æ¯”)
    const ignoreDefP = this.getBuffValue(caster, 'IGNORE_DEF_P');
    
    // è®¡ç®—æœ‰æ•ˆé˜²å¾¡
    const effectiveDef = Math.max(0, 
      (baseDef * (1 + defBonus) - ignoreDefFlat) * (1 - ignoreDefP)
    );
    
    return effectiveDef;
  }

  /**
   * è®¡ç®—æœ€ç»ˆä¼¤å®³
   */
  private static computeFinalDamage(
    atk: number,
    critDmg: number,
    damageBonus: number,
    damageTakenBonus: number,
    defense: number,
    multiplier: number
  ): number {
    // é˜²å¾¡å‡å…å…¬å¼: 300 / (300 + é˜²å¾¡)
    const defenseMultiplier = 300 / (300 + defense);
    
    // ä¼¤å®³å¢ç›Š
    const totalBonus = (1 + damageBonus) * (1 + damageTakenBonus);
    
    // æœ€ç»ˆè®¡ç®—
    const damage = atk * critDmg * totalBonus * defenseMultiplier * multiplier;
    
    return damage;
  }

  // ==================== è¾…åŠ©æ–¹æ³• ====================

  /**
   * è·å–è£…å¤‡æä¾›çš„å›ºå®šæ”»å‡»åŠ›
   */
  private static getEquipmentFlatAttack(caster: CharacterInstance): number {
    let totalAtk = 0;
    
    for (const equipId of caster.equipment) {
      const equip = this.getEquipmentById(equipId);
      if (equip?.baseStats?.ATK) {
        totalAtk += equip.baseStats.ATK;
      }
    }
    
    return totalAtk;
  }

  /**
   * è®¡ç®—ä¼¤å®³å¢ç›Š (ç™¾åˆ†æ¯”)
   */
  private static calculateDamageBonus(caster: CharacterInstance): number {
    let bonus = caster.currentStats.DMG_BONUS || 0;
    bonus += this.getBuffBonus(caster, 'DMG_BONUS');
    return bonus;
  }

  /**
   * è®¡ç®—æ‰¿å—ä¼¤å®³å¢ç›Š (ç™¾åˆ†æ¯”)
   */
  private static calculateDamageTakenBonus(target: CharacterInstance): number {
    let bonus = target.currentStats.DMG_TAKEN_BONUS || 0;
    bonus += this.getBuffBonus(target, 'DMG_TAKEN_BONUS');
    return bonus;
  }

  /**
   * è·å–Buffæ•°å€¼
   */
  private static getBuffBonus(character: CharacterInstance, statType: string): number {
    return character.statuses
      .filter(status => status.type === statType)
      .reduce((total, status) => total + (status.effect?.value || 0), 0);
  }

  /**
   * è·å–Buffæ•°å€¼ (ç®€åŒ–ç‰ˆ)
   */
  private static getBuffValue(character: CharacterInstance, statType: string): number {
    // TODO: å®ç°Buffå€¼è·å–
    return 0;
  }

  /**
   * è·å–ç­‰çº§å¯¹åº”æˆé•¿ç‚¹
   */
  private static getGrowthPoints(level: number): number {
    const growthTable: Record<number, number> = {
      1: 10, 5: 25, 10: 45, 15: 68, 20: 92, 25: 118,
      30: 146, 35: 176, 40: 208, 45: 242, 50: 278
    };
    
    return growthTable[level] || 0;
  }

  /**
   * é€šè¿‡IDè·å–è£…å¤‡ (éœ€è¦å®ç°è£…å¤‡æ•°æ®åº“)
   */
  private static getEquipmentById(id: string): any {
    // TODO: ä»è£…å¤‡æ•°æ®åº“è·å–
    return null;
  }
}
```

### 10.2 è¾¹ç¼˜æƒ…å†µå¤„ç†

**é˜²å¾¡è¾¹ç•Œæµ‹è¯•ï¼š**

```typescript
// æµ‹è¯•ç”¨ä¾‹ - é˜²å¾¡è¾¹ç•Œå¤„ç†
describe('DamageCalculator Edge Cases', () => {
  it('åº”è¯¥å¤„ç†é˜²å¾¡ä¸º0çš„æƒ…å†µ', () => {
    const caster = createCaster({ ATK: 1000 });
    const target = createTarget({ DEF: 0 });
    
    const damage = DamageCalculator.calculateDamage(caster, target, 1.0);
    
    // é˜²å¾¡ä¸º0æ—¶ä¼¤å®³åº”è¯¥è¾¾åˆ°æœ€å¤§å€¼
    expect(damage).toBeGreaterThan(1200);
  });

  it('åº”è¯¥å¤„ç†æé«˜é˜²å¾¡çš„æƒ…å†µ', () => {
    const caster = createCaster({ ATK: 1000 });
    const target = createTarget({ DEF: 2000 });
    
    const damage = DamageCalculator.calculateDamage(caster, target, 1.0);
    
    // æé«˜é˜²å¾¡æ—¶ä¼¤å®³åº”è¯¥è¢«å¤§å¹…å‰Šå‡
    expect(damage).toBeLessThan(400);
  });

  it('åº”è¯¥å¤„ç†é˜²å¾¡ç©¿é€è¿‡å¼ºçš„æƒ…å†µ', () => {
    const caster = createCaster({ 
      ATK: 1000,
      IGNORE_DEF_FLAT: 1000 
    });
    const target = createTarget({ DEF: 500 });
    
    const damage = DamageCalculator.calculateDamage(caster, target, 1.0);
    
    // é˜²å¾¡ç©¿é€ä½¿é˜²å¾¡ä¸ºè´Ÿæ—¶ï¼Œåº”è¯¥è§†ä¸º0
    expect(damage).toBeGreaterThan(900);
  });
});
```

---

## 11. AIåŠ©æ‰‹åä½œæŒ‡å—

### 11.1 è§’è‰²è®¾å®šä¸æ€ç»´é“¾

**ç³»ç»ŸæŒ‡ä»¤æ¨¡æ¿ï¼š**

```
ä½ æ˜¯ä¸€åèµ„æ·±çš„æ¸¸æˆå¼•æ“æ¶æ„å¸ˆï¼Œç²¾é€šTypeScriptå’ŒReactæ€§èƒ½ä¼˜åŒ–ã€‚

æ ¸å¿ƒèŒè´£ï¼š
1. ä¸¥æ ¼æŒ‰ç…§SSOTç±»å‹å®šä¹‰ç¼–å†™ä»£ç 
2. åœ¨å¤æ‚é€»è¾‘å‰å…ˆå†™æµ‹è¯•ç”¨ä¾‹
3. éµå¾ªç•Œé¢ä¸é€»è¾‘åˆ†ç¦»åŸåˆ™
4. æ‰€æœ‰ç¡¬ç¼–ç å¿…é¡»å¼•ç”¨TERMSé…ç½®

æ€ç»´é“¾è¦æ±‚ï¼š
åœ¨ç¼–å†™ä»»ä½•å¤æ‚é€»è¾‘ï¼ˆå¦‚ä¼¤å®³è®¡ç®—ã€å›åˆç®¡ç†ï¼‰ä¹‹å‰ï¼Œä½ å¿…é¡»ï¼š
1. ç”¨è‡ªç„¶è¯­è¨€åœ¨æ³¨é‡Šä¸­å†™å‡ºè®¡ç®—æ­¥éª¤
2. è¯†åˆ«æ‰€æœ‰è¾¹ç•Œæ¡ä»¶
3. ç¼–å†™ç›¸åº”çš„æµ‹è¯•ç”¨ä¾‹
4. ç„¶åå†ç¼–å†™å®ç°ä»£ç 

æœ¯è¯­æ£€æŸ¥ï¼š
æ¯æ¬¡è¾“å‡ºä»£ç å‰ï¼Œè‡ªæˆ‘æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†ç¡¬ç¼–ç å­—ç¬¦ä¸²ã€‚
å¦‚æœ‰å‘ç°ï¼Œç«‹å³æ›¿æ¢ä¸ºTERMSå¼•ç”¨ã€‚

ç¦æ­¢å‡è®¾ï¼š
å¦‚æœæ–‡æ¡£ä¸­æœªå®šä¹‰æŸä¸ªæœºåˆ¶ï¼Œå…ˆè¯¢é—®ç”¨æˆ·ç¡®è®¤ï¼Œä¸è¦è‡ªè¡Œå‘æŒ¥ã€‚
```

### 11.2 å¼€å‘ä»»åŠ¡æ¨¡æ¿

**æ–°åŠŸèƒ½å¼€å‘æµç¨‹ï¼š**

```typescript
/**
 * åŠŸèƒ½å¼€å‘æ¨¡æ¿
 * 
 * æ­¥éª¤1: å®šä¹‰éœ€æ±‚
 * - æ˜ç¡®åŠŸèƒ½ç›®æ ‡å’Œè¾¹ç•Œ
 * - è¯†åˆ«éœ€è¦çš„ç±»å‹å®šä¹‰
 * 
 * æ­¥éª¤2: ç¼–å†™æµ‹è¯•
 * - åˆ›å»ºå¤±è´¥çš„æµ‹è¯•ç”¨ä¾‹
 * - è¦†ç›–è¾¹ç•Œæƒ…å†µ
 * 
 * æ­¥éª¤3: å®ç°åŠŸèƒ½
 * - éµå¾ªSSOTç±»å‹å®šä¹‰
 * - åˆ†ç¦»UIå’Œé€»è¾‘
 * 
 * æ­¥éª¤4: éªŒè¯é€šè¿‡
 * - ç¡®ä¿æ‰€æœ‰æµ‹è¯•é€šè¿‡
 * - æ£€æŸ¥TypeScriptç±»å‹
 */

// TODO: åœ¨è¿™é‡Œå®ç°åŠŸèƒ½
```

### 11.3 å¸¸è§é”™è¯¯é¢„é˜²

**LLMå¸¸è§é”™è¯¯æ¸…å•ï¼š**

1. **ç±»å‹å®šä¹‰å†²çª** âŒ
   - é”™è¯¯ï¼šåœ¨å¤šä¸ªæ–‡ä»¶å®šä¹‰ç›¸åŒæ¥å£
   - æ­£ç¡®ï¼šç»Ÿä¸€åœ¨ `src/core/types/` å®šä¹‰

2. **ç¡¬ç¼–ç æœ¯è¯­** âŒ
   - é”™è¯¯ï¼š`"é¬¼ç«"` ç›´æ¥å†™åœ¨ç»„ä»¶ä¸­
   - æ­£ç¡®ï¼šä½¿ç”¨ `TERMS.BATTLE_RESOURCE`

3. **UIç›´æ¥ä¿®æ”¹çŠ¶æ€** âŒ
   - é”™è¯¯ï¼šReactç»„ä»¶ç›´æ¥ä¿®æ”¹BattleState
   - æ­£ç¡®ï¼šé€šè¿‡BattleEngineæ–¹æ³•

4. **å¿½ç•¥è¾¹ç•Œæ¡ä»¶** âŒ
   - é”™è¯¯ï¼šåªå¤„ç†æ­£å¸¸æƒ…å†µ
   - æ­£ç¡®ï¼šç¼–å†™è¾¹ç•Œæµ‹è¯•ç”¨ä¾‹

5. **è¿ååˆ†ç¦»åŸåˆ™** âŒ
   - é”™è¯¯ï¼šåœ¨æ ¸å¿ƒé€»è¾‘ä¸­å¼•å…¥UIä»£ç 
   - æ­£ç¡®ï¼šä¿æŒçº¯TypeScripté€»è¾‘å±‚

---

## 12. éƒ¨ç½²ä¸è·¨å¹³å°ç­–ç•¥

### 12.1 æ¶æ„é€‚é…å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     è·¨å¹³å°æ¶æ„                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¡Œé¢åº”ç”¨ (Tauri)  â”‚  ç§»åŠ¨åº”ç”¨ (Capacitor)  â”‚  Webåº”ç”¨ (Vite)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    UIæ¡†æ¶å±‚ (å¯æ›¿æ¢)                          â”‚
â”‚  React Components  â”‚  Vue Components     â”‚  Other Frameworks â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 UIæ¡¥æ¥å±‚ (æ ‡å‡†åŒ–æ¥å£)                         â”‚
â”‚    ReactAdapter    â”‚    VueAdapter       â”‚   Common Bridge   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   æ ¸å¿ƒé€»è¾‘å±‚ (çº¯TS)                          â”‚
â”‚  BattleEngine  â”‚  TurnManager  â”‚  DamageCalculator  â”‚  Plugins â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 è·¨å¹³å°å°è£…å±‚                                 â”‚
â”‚      Tauri Rust Core      â”‚        Capacitor Native        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 12.2 æ„å»ºé…ç½®

**`package.json` å…³é”®è„šæœ¬ï¼š**

```json
{
  "scripts": {
    "dev": "vite",                           // Webå¼€å‘æ¨¡å¼
    "build:web": "vite build",               // Webæ„å»º
    "build:tauri": "tauri build",            // æ¡Œé¢åº”ç”¨æ„å»º
    "build:capacitor": "capacitor build",    // ç§»åŠ¨åº”ç”¨æ„å»º
    "test": "vitest",                        // è¿è¡Œæµ‹è¯•
    "test:coverage": "vitest run --coverage", // æµ‹è¯•è¦†ç›–ç‡
    "lint": "eslint src --ext .ts,.tsx",     // ä»£ç æ£€æŸ¥
    "type-check": "tsc --noEmit"             // ç±»å‹æ£€æŸ¥
  }
}
```

**Viteé…ç½®ä¼˜åŒ–ï¼š**

```typescript
// vite.config.ts
export default defineConfig({
  plugins: [react()],
  build: {
    lib: {
      entry: 'src/core/index.ts',           // æ ¸å¿ƒé€»è¾‘ç‹¬ç«‹æ‰“åŒ…
      formats: ['es'],                      // ESæ¨¡å—æ ¼å¼
      fileName: 'core'                      // æ–‡ä»¶å
    },
    rollupOptions: {
      external: ['react', 'react-dom']      // å¤–éƒ¨ä¾èµ–
    }
  },
  optimizeDeps: {
    include: ['zustand']                    // ä¼˜åŒ–ä¾èµ–
  }
});
```

### 12.3 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**æ ¸å¿ƒé€»è¾‘ä¼˜åŒ–ï¼š**
- **ä»£ç åˆ†å‰²ï¼š** æ ¸å¿ƒé€»è¾‘ä¸UIæ¡†æ¶åˆ†ç¦»
- **æ‡’åŠ è½½ï¼š** æ’ä»¶æŒ‰éœ€åŠ è½½
- **ç¼“å­˜æœºåˆ¶ï¼š** æˆ˜æ–—çŠ¶æ€æ™ºèƒ½ç¼“å­˜
- **å†…å­˜ç®¡ç†ï¼š** åŠæ—¶é‡Šæ”¾ä¸ç”¨çš„æ’ä»¶å®ä¾‹

**UIæ€§èƒ½ä¼˜åŒ–ï¼š**
- **è™šæ‹ŸåŒ–ï¼š** å¤§é‡è§’è‰²æ¸²æŸ“ä¼˜åŒ–
- **é˜²æŠ–å¤„ç†ï¼š** é¢‘ç¹