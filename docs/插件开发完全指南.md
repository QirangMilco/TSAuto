# TSAuto 插件开发完全指南

## 1. 插件系统概述

TSAuto 项目的插件系统设计灵活，支持多种加载方式，能够适应不同的开发和生产环境需求。通过插件系统，玩家和模组作者可以自定义游戏内容，包括角色、技能、装备、状态和套装效果等。

### 核心组件

- **PluginLoader**：负责动态加载各类插件模块
- **PluginManager**：负责插件系统的整体管理和协调
- **PluginValidator**：验证插件是否符合接口规范
- **SetEffectRegistry**：管理和执行套装效果函数
- **静态插件映射**：用于生产环境下的插件加载

## 2. 可自定义的插件内容

TSAuto 插件系统支持以下类型的自定义内容：

### 2.1 角色插件 (Character)

**自定义内容**：
- 角色基础属性和成长曲线
- 角色技能配置
- 角色外观和动画
- 角色特殊机制

**示例应用**：
- 创建新的仙神角色
- 自定义角色技能组合
- 修改现有角色属性

### 2.2 技能插件 (Skill)

**自定义内容**：
- 技能效果和伤害公式
- 技能消耗和冷却机制
- 技能目标选择逻辑
- 技能动画和特效

**示例应用**：
- 创建新的主动技能
- 设计特殊机制的被动技能
- 调整现有技能的效果

### 2.3 装备插件 (Equipment)

**自定义内容**：
- 装备基础属性和副属性
- 装备套装关联
- 装备外观和特效
- 装备强化机制

**示例应用**：
- 创建新的御魂装备
- 设计特殊属性的装备
- 调整装备掉落概率

### 2.4 状态插件 (Status)

**自定义内容**：
- 状态效果和持续时间
- 状态叠加和刷新机制
- 状态动画和特效
- 状态触发条件

**示例应用**：
- 创建新的增益/减益状态
- 设计特殊机制的状态
- 调整现有状态的效果

### 2.5 套装效果插件 (Equipment Set)

**自定义内容**：
- 套装属性加成
- 套装战斗机制效果
- 套装触发条件
- 套装效果函数

**示例应用**：
- 创建新的套装效果（如破势、针女等）
- 设计特殊机制的套装效果
- 调整现有套装的效果

## 3. 插件开发方式

### 3.1 开发环境准备

**1. 安装依赖**
```bash
npm install
```

**2. 启动开发服务器**
```bash
npm run dev
```

**3. 项目结构**
```
├── plugins/              # 插件目录
│   ├── characters/       # 角色插件
│   ├── skills/           # 技能插件
│   ├── equipment/        # 装备插件
│   ├── statuses/         # 状态插件
│   └── equipment-sets/   # 套装插件
├── src/                  # 源代码目录
│   ├── core/             # 核心逻辑
│   │   ├── plugin/       # 插件系统
│   │   ├── battle/       # 战斗系统
│   │   └── config/       # 配置文件
│   └── types/            # 类型定义
└── docs/                 # 文档
```

### 3.2 插件开发工具

- **编辑器**：推荐使用 VS Code，支持 TypeScript 类型检查
- **构建工具**：Vite，支持热更新和 TypeScript 编译
- **测试框架**：Vitest，用于插件功能测试
- **版本控制**：Git，用于插件代码管理

## 4. 插件接口定义

### 4.1 基础接口

所有插件都应该遵循以下基础结构：

```typescript
// 插件内容（默认导出）
export default {
  id: string;           // 唯一标识符
  name: string;         // 插件名称
  // 其他插件类型特定的属性
};

// 插件元数据（可选）
export const metadata = {
  version: string;      // 插件版本
  author: string;       // 作者名称
  description: string;  // 插件描述
  // 其他元数据
};
```

### 4.2 角色插件接口

```typescript
interface CharacterDefinition {
  id: string;
  name: string;
  baseStats: Record<StatType, number>;  // 基础属性
  growthStats: Record<StatType, number>; // 成长属性
  skills: string[];                     // 技能ID列表
  // 其他角色特定属性
}
```

### 4.3 技能插件接口

```typescript
interface SkillDefinition {
  id: string;
  name: string;
  cost: { type: ResourceType; amount: number }; // 消耗
  activeEffects: Effect[];                      // 主动效果
  passiveEffects?: Effect[];                    // 被动效果
  targetType: TargetType;                       // 目标类型
  // 其他技能特定属性
}
```

### 4.4 装备插件接口

```typescript
interface EquipmentDefinition {
  id: string;
  name: string;
  slot: number;         // 部位 (1-5)
  setId: string;        // 套装ID
  // 其他装备特定属性
}
```

### 4.5 状态插件接口

```typescript
interface StatusDefinition {
  id: string;
  name: string;
  type: BuffType;       // 状态类型
  duration?: number;    // 持续时间（回合数）
  effects: Effect[];    // 状态效果
  // 其他状态特定属性
}
```

### 4.6 套装效果接口

```typescript
// 套装定义
interface SetBonusDefinition {
  id: string;
  name: string;
  effects: Record<number, SetEffectDefinition>; // 按件数定义的效果
}

// 套装效果定义
interface SetEffectDefinition {
  stat?: StatType;      // 属性类型
  value?: number;       // 属性值
  description?: string; // 效果描述
  effectId?: string;    // 关联到战斗系统的效果ID
}

// 套装效果函数接口
type SetEffectFunction = (context: SetEffectContext) => any;

// 套装效果上下文
interface SetEffectContext {
  character: any;         // 触发效果的角色
  target?: any;           // 目标角色
  battleState: any;       // 当前战斗状态
  eventType: BattleEventType; // 事件类型
  damage?: number;        // 当前伤害值
  isCrit?: boolean;       // 是否暴击
  skillId?: string;       // 使用的技能ID
  battleEngine: any;      // 战斗引擎实例
}
```

## 5. 插件加载和导入方式

### 5.1 插件加载模式

插件系统支持三种加载模式，可根据不同环境和需求选择：

#### 5.1.1 动态加载模式 (Dynamic)

**适用场景**：开发环境，便于开发和调试

**工作原理**：
- 使用Vite的`import.meta.glob`功能动态扫描和加载插件
- 支持热更新，修改插件后无需重启应用
- 插件内容在运行时动态加载

**配置示例**：
```typescript
const pluginManager = new PluginManager({
  mode: 'dynamic'
});
```

#### 5.1.2 静态加载模式 (Static)

**适用场景**：生产环境，提高性能

**工作原理**：
- 构建时生成静态插件导入映射
- 所有插件在构建时打包到主程序中
- 运行时直接从内存加载，无需动态导入

**配置示例**：
```typescript
import { staticPluginImports } from './core/plugin/static-plugins.generated';

const pluginManager = new PluginManager({
  mode: 'static',
  staticPlugins: staticPluginImports
});
```

#### 5.1.3 资源目录加载模式 (Resource)

**适用场景**：需要动态添加插件的场景

**工作原理**：
- 从应用的资源目录读取插件文件
- 支持从网络或本地文件系统加载
- 插件内容在运行时动态解析

**配置示例**：
```typescript
const pluginManager = new PluginManager({
  mode: 'resource',
  resourceBasePath: './resources'
});
```

### 5.2 插件导入API

#### 5.2.1 加载单个插件

```typescript
async loadPlugin(path: string, pluginData?: any): Promise<{
  success: boolean;
  id?: string;
  error?: string;
}>;
```

#### 5.2.2 批量导入插件

```typescript
async importPlugins(pluginPaths: string[]): Promise<{
  success: boolean;
  imported: string[];
  failed: { path: string; error: string }[];
  total: number;
}>;
```

#### 5.2.3 从数据导入插件

```typescript
async importPluginFromData(
  pluginData: any,
  type: PluginType,
  customId?: string
): Promise<{
  success: boolean;
  id?: string;
  error?: string;
}>;
```

#### 5.2.4 注册套装效果

```typescript
// 获取套装效果注册表实例
const registry = SetEffectRegistry.getInstance();

// 注册单个效果
registry.registerEffect(effectId, effectFunction);

// 批量注册效果
registry.registerEffects(effectsMap);
```

#### 5.2.5 注册技能机制

```typescript
// 获取技能机制注册表实例
const registry = SkillMechanicRegistry.getInstance();

// 注册单个技能机制
registry.registerMechanic(mechanicId, mechanicFunction);

// 批量注册技能机制
registry.registerMechanics(mechanicsMap);
```

## 5.3 Runtime Plugin Development (Experimental)

运行时插件加载允许在浏览器中直接导入 TypeScript 源码，无需重新打包。核心能力由 `RuntimePluginLoader` 与 `TSAutoAPI` 提供。

- **入口**：`PluginManager.loadRuntimePlugin(source: string, filename: string)` 会调用 SWC(wasm) 转译并在沙箱中执行。
- **可用导入**：在插件中使用 `import { PluginType, StatType, ... } from 'tsauto-api';` 或 `const { PluginType } = require('tsauto-api');`，符号由注入的 `TSAutoAPI` 提供。
- **安全限制**：沙箱 `require` 仅允许 `tsauto-api`，禁止 Node 内置包/其他依赖；执行失败会抛出详细错误。
- **元数据**：可导出 `metadata = { type, version, author }`；未显式提供时会根据文件名推断类型，版本/作者默认 `1.0.0`/`Unknown`。

**示例**：
```typescript
// runtime_skill_demo.ts
import { PluginType, StatType } from 'tsauto-api';

export default {
  id: 'RUNTIME_SKILL_DEMO',
  name: 'Runtime Skill Demo',
  baseStats: { [StatType.ATK]: 10 }
};

export const metadata = {
  type: PluginType.SKILL,
  version: '0.1.0',
  author: 'Runtime Dev'
};
```

## 6. 开发流程

### 6.1 插件开发流程

1. **选择插件类型**：根据需求选择要开发的插件类型
2. **创建插件文件**：在`plugins`目录下创建对应类型的插件文件
3. **编写插件代码**：根据插件接口定义编写插件内容
4. **测试插件功能**：在开发环境中测试插件效果
5. **优化和调试**：根据测试结果优化插件代码
6. **发布插件**：将插件打包或发布到插件仓库

### 6.2 套装效果开发流程

1. **定义套装效果**：在`equipmentSets.ts`中定义套装效果
2. **实现效果函数**：编写套装效果的执行逻辑
3. **注册效果函数**：将效果函数注册到`SetEffectRegistry`
4. **测试效果触发**：在战斗中测试套装效果是否正确触发
5. **优化效果逻辑**：根据测试结果优化效果函数

### 6.3 开发示例：创建破势套装效果

**1. 在`equipmentSets.ts`中定义套装**
```typescript
export const EQUIPMENT_SETS = {
  'PO_SHI': {
    id: 'PO_SHI',
    name: '破势',
    effects: {
      2: { stat: StatType.CRIT, value: 15 },
      4: { 
        description: "对生命值高于70%的单位造成额外40%伤害", 
        effectId: "EFF_POSHI" 
      }
    }
  }
};
```

**2. 实现效果函数**
```typescript
const poshiEffect: SetEffectFunction = (context) => {
  if (context.eventType === 'ON_DAMAGE_DEALT' && context.target) {
    const hpRatio = context.target.currentHp / context.target.maxHp;
    if (hpRatio > 0.7) {
      return {
        damageMultiplier: 1.4,
        message: `${context.character.name}触发了破势效果，对生命值高于70%的目标造成额外伤害！`
      };
    }
  }
  return {};
};
```

**3. 注册效果函数**
```typescript
SetEffectRegistry.getInstance().registerEffect('EFF_POSHI', poshiEffect);
```

### 6.4 技能机制开发流程

1. **定义技能机制**：确定技能机制的功能和触发条件
2. **实现机制函数**：编写技能机制的执行逻辑
3. **注册机制函数**：将机制函数注册到`SkillMechanicRegistry`
4. **关联到技能**：在技能定义中添加`mechanicId`字段
5. **测试机制触发**：在战斗中测试技能机制是否正确触发
6. **优化机制逻辑**：根据测试结果优化机制函数

### 6.5 开发示例：创建协战技能机制

**1. 实现技能机制函数**
```typescript
const assistMechanic: SkillMechanicFunction = (context) => {
  // 随机选择一个队友进行协战
  const teammates = [...context.battleState.players];
  if (teammates.length > 0) {
    const assistCharacter = teammates[Math.floor(Math.random() * teammates.length)];
    
    // 触发协战攻击
    return {
      assist: {
        character: assistCharacter,
        skillId: assistCharacter.skills[0] // 使用默认技能
      },
      message: `${context.caster.name}触发了${assistCharacter.name}的协战！`
    };
  }
  return {};
};
```

**2. 注册技能机制**
```typescript
SkillMechanicRegistry.getInstance().registerMechanic('MECH_ASSIST', assistMechanic);
```

**3. 在技能中使用机制**
```typescript
// plugins/skills/skill_1001.ts
export default {
  id: 'SKILL_1001',
  name: '风切',
  cost: {
    type: ResourceType.BATTLE_RESOURCE,
    amount: 0
  },
  activeEffects: [
    {
      type: EffectType.DAMAGE,
      target: TargetType.TARGET,
      damageMultiplier: 1.0,
      baseDamageStat: StatType.ATK
    }
  ],
  mechanicId: 'MECH_ASSIST', // 关联协战机制
  description: '对目标造成伤害，有概率触发队友协战'
};
```

**4. 测试机制效果**
- 在开发环境中启动游戏
- 选择带有协战机制的技能
- 观察技能使用后是否触发队友协战
- 检查控制台日志，确认机制执行结果

### 6.6 开发示例：创建被动伤害反弹机制

**1. 实现伤害反弹机制**
```typescript
const reflectMechanic: SkillMechanicFunction = (context) => {
  if (context.eventType === BattleEventType.ON_DAMAGE_RECEIVED && context.damageResult) {
    const reflectDamage = context.damageResult.damage * 0.3;
    return {
      reflectDamage,
      message: `${context.caster.name}反弹了${reflectDamage}点伤害！`
    };
  }
  return {};
};
```

**2. 注册机制**
```typescript
SkillMechanicRegistry.getInstance().registerMechanic('MECH_DAMAGE_REFLECT', reflectMechanic);
```

**3. 在被动技能中使用**
```typescript
// plugins/skills/passive_reflect.ts
export default {
  id: 'PASSIVE_REFLECT',
  name: '伤害反弹',
  cost: {
    type: ResourceType.BATTLE_RESOURCE,
    amount: 0
  },
  passiveListeners: [
    {
      event: BattleEventType.ON_DAMAGE_RECEIVED,
      effects: [],
      mechanicId: 'MECH_DAMAGE_REFLECT' // 关联伤害反弹机制
    }
  ],
  description: '受到伤害时，反弹30%伤害给攻击者'
};
```

## 7. 测试和调试

### 7.1 开发环境测试

1. **启动开发服务器**：`npm run dev`
2. **查看控制台日志**：检查插件加载和执行日志
3. **使用开发工具**：使用浏览器开发者工具调试插件
4. **测试战斗场景**：创建测试战斗，验证插件效果

### 7.2 单元测试

```bash
# 运行所有测试
npm run test

# 运行特定测试文件
npm run test tests/unit/plugins/PluginLoading.test.ts
```

### 7.3 集成测试

1. **创建测试场景**：在游戏中创建包含新插件的测试场景
2. **测试插件交互**：验证不同插件之间的交互
3. **测试边界情况**：测试插件在各种边界条件下的表现
4. **性能测试**：测试插件对游戏性能的影响

## 8. 发布和分发

### 8.1 插件打包

**开发环境插件**：
- 直接将插件文件放入`plugins`目录
- 无需额外打包

**生产环境插件**：
```bash
# 生成静态插件映射
npm run generate-plugins

# 构建项目
npm run build
```

### 8.2 插件分发

1. **直接文件分发**：将插件文件直接提供给用户，用户放入`plugins`目录
2. **插件包分发**：将插件打包成zip文件，包含安装说明
3. **插件仓库分发**：发布到官方插件仓库，用户通过游戏内插件管理器安装

### 8.3 插件版本管理

- 遵循语义化版本控制（SemVer）
- 在插件元数据中明确版本信息
- 提供版本更新日志
- 确保向后兼容性

## 9. 最佳实践

### 9.1 插件开发最佳实践

1. **使用唯一ID**：为每个插件分配唯一的ID，避免冲突
2. **详细元数据**：提供完整的插件元数据，便于用户了解
3. **类型安全**：严格遵循TypeScript接口定义，确保类型安全
4. **模块化设计**：将复杂插件拆分为多个模块，便于维护
5. **注释清晰**：为插件代码添加详细注释，便于其他开发者理解
6. **性能优化**：优化插件代码，减少对游戏性能的影响
7. **测试充分**：对插件进行充分测试，确保功能正常

### 9.2 套装效果开发最佳实践

1. **明确触发条件**：清晰定义套装效果的触发条件
2. **效果可预测**：确保套装效果的表现符合玩家预期
3. **平衡设计**：避免设计过于强势或弱势的套装效果
4. **与现有系统兼容**：确保新套装效果与现有战斗系统兼容
5. **支持多种事件类型**：考虑在不同事件类型下触发效果

### 9.3 安全性最佳实践

1. **验证插件内容**：对外部插件进行内容验证，防止恶意代码
2. **限制访问权限**：限制插件对游戏核心功能的访问权限
3. **使用沙箱环境**：考虑在沙箱环境中运行外部插件
4. **定期更新**：及时更新插件，修复安全漏洞
5. **用户提示**：向用户提示使用外部插件的风险

## 10. 预设技能机制

TSAuto 项目提供了多种预设的技能机制，模组作者可以直接使用这些机制，也可以基于它们进行扩展。

### 10.1 协战机制 (MECH_ASSIST)
- **效果**：随机选择一个队友进行协战攻击
- **触发条件**：主动技能使用时
- **机制ID**：MECH_ASSIST
- **示例**：茨木童子的被动协战

### 10.2 多段伤害机制 (MECH_MULTI_HIT)
- **效果**：造成多段伤害，每段伤害独立计算
- **触发条件**：主动技能使用时
- **机制ID**：MECH_MULTI_HIT
- **示例**：姑获鸟的多段攻击

### 10.3 伤害反弹机制 (MECH_DAMAGE_REFLECT)
- **效果**：反弹一部分伤害给攻击者
- **触发条件**：受到伤害时
- **机制ID**：MECH_DAMAGE_REFLECT
- **示例**：镜姬御魂效果

### 10.4 生命偷取机制 (MECH_LIFE_STEAL)
- **效果**：偷取伤害的一部分作为生命值
- **触发条件**：造成伤害时
- **机制ID**：MECH_LIFE_STEAL
- **示例**：吸血姬的技能效果

### 10.5 状态扩散机制 (MECH_STATUS_SPREAD)
- **效果**：将目标身上的状态扩散到其他敌人
- **触发条件**：主动技能使用时
- **机制ID**：MECH_STATUS_SPREAD
- **示例**：鬼使白的技能效果

### 10.6 鬼火消耗机制 (MECH_SPIRIT_FIRE_COST)
- **效果**：根据当前鬼火数量增加伤害
- **触发条件**：主动技能使用时
- **机制ID**：MECH_SPIRIT_FIRE_COST
- **示例**：荒川之主的技能效果

## 11. 示例插件

### 11.1 角色插件示例

```typescript
// plugins/characters/character_1001.ts
export default {
  id: 'CHAR_1001',
  name: '风语者 艾琳',
  baseStats: {
    [StatType.HP]: 1200,
    [StatType.ATK]: 100,
    [StatType.DEF]: 50,
    [StatType.SPD]: 110,
    [StatType.CRIT]: 5,
    [StatType.CRIT_DMG]: 150
  },
  growthStats: {
    [StatType.HP]: 60,
    [StatType.ATK]: 5,
    [StatType.DEF]: 2.5,
    [StatType.SPD]: 5
  },
  skills: ['SKILL_1001', 'SKILL_1002', 'SKILL_1003']
};

export const metadata = {
  version: '1.0.0',
  author: 'TSAuto Team',
  description: '风属性角色，擅长群体攻击和速度加成'
};
```

### 11.2 技能插件示例

```typescript
// plugins/skills/skill_1001.ts
export default {
  id: 'SKILL_1001',
  name: '风切',
  cost: {
    type: ResourceType.BATTLE_RESOURCE,
    amount: 0
  },
  activeEffects: [
    {
      type: EffectType.DAMAGE,
      target: TargetType.TARGET,
      damageMultiplier: 1.0,
      baseDamageStat: StatType.ATK
    }
  ],
  mechanicId: 'MECH_ASSIST', // 关联协战机制
  targetType: TargetType.TARGET
};

export const metadata = {
  version: '1.0.0',
  author: 'TSAuto Team',
  description: '基础攻击技能，对单个目标造成伤害，有概率触发队友协战'
};
```

### 11.3 装备插件示例

```typescript
// plugins/equipment/equip_2001.ts
export default {
  id: 'EQUIP_2001',
  name: '风语之刃',
  slot: 1,
  setId: 'WIND_SET',
  // 其他装备属性
};

export const metadata = {
  version: '1.0.0',
  author: 'TSAuto Team',
  description: '风语套装的武器，增加攻击和速度'
};
```

## 12. 常见问题和解决方案

### 12.1 插件加载失败

**可能原因**：
- 插件ID重复
- 插件格式不符合接口规范
- 插件依赖缺失
- 加载模式配置错误

**解决方案**：
- 检查插件ID是否唯一
- 验证插件格式是否符合接口定义
- 确保所有依赖都已正确安装
- 检查加载模式配置是否正确

### 12.2 插件效果不触发

**可能原因**：
- 触发条件不满足
- 效果函数有错误
- 插件没有正确注册
- 事件类型不匹配

**解决方案**：
- 检查触发条件是否正确
- 检查效果函数代码是否有错误
- 确保插件已正确注册
- 检查事件类型是否匹配

### 12.3 技能机制不执行

**可能原因**：
- 机制ID拼写错误
- 机制函数未注册
- 触发条件不满足
- 事件类型不匹配

**解决方案**：
- 检查机制ID是否正确
- 确保机制函数已注册到SkillMechanicRegistry
- 检查技能是否正确关联了机制ID
- 检查触发事件类型是否匹配

### 12.4 插件性能问题

**可能原因**：
- 插件代码效率低下
- 插件触发频率过高
- 插件占用过多内存

**解决方案**：
- 优化插件代码，减少计算量
- 降低插件触发频率
- 优化内存使用，及时释放资源

## 13. 总结

TSAuto 项目的插件系统设计灵活，支持多种类型的自定义内容，能够满足玩家和模组作者的各种需求。通过合理使用插件系统，可以为游戏添加丰富的内容，提高游戏的可玩性和扩展性。

本指南详细介绍了TSAuto插件系统的设计、开发方式、接口定义和最佳实践，希望能够帮助开发者快速上手插件开发，为TSAuto游戏社区贡献更多优秀的插件。

插件开发是一个持续学习和探索的过程，建议开发者在实践中不断积累经验，尝试新的设计思路和技术方案，为游戏带来更多创新和乐趣。

## 14. 附录

### 14.1 常用常量和枚举

**StatType**：属性类型枚举
- HP: 生命值
- ATK: 攻击
- DEF: 防御
- SPD: 速度
- CRIT: 暴击率
- CRIT_DMG: 暴击伤害
- 等其他属性类型

**EffectType**：效果类型枚举
- DAMAGE: 伤害
- HEAL: 治疗
- APPLY_STATUS: 应用状态
- MODIFY_ACTION_BAR: 修改行动条
- GAIN_EXTRA_TURN: 获得额外回合
- 等其他效果类型

**TargetType**：目标类型枚举
- SELF: 自身
- TARGET: 目标
- ALL_ALLIES: 所有队友
- ALL_ENEMIES: 所有敌人
- RANDOM_ENEMY: 随机敌人
- 等其他目标类型

**BattleEventType**：战斗事件类型
- ON_BATTLE_START: 战斗开始
- ON_TURN_START: 回合开始
- ON_TURN_END: 回合结束
- ON_DAMAGE_DEALT: 造成伤害
- ON_DAMAGE_RECEIVED: 受到伤害
- ON_HEAL_RECEIVED: 受到治疗
- 等其他战斗事件

### 14.2 开发资源

- **项目文档**：查看项目中的其他文档文件
- **代码注释**：阅读源代码中的注释
- **示例插件**：参考项目中的示例插件
- **社区论坛**：参与TSAuto插件开发社区讨论

### 14.3 联系方式

- **官方网站**：https://tsauto.example.com
- **GitHub仓库**：https://github.com/tsauto/tsauto
- **Discord社区**：https://discord.gg/tsauto
- **开发者邮箱**：dev@tsauto.example.com